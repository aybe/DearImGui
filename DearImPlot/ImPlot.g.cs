// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma warning disable CS0109 // The member 'member' does not hide an inherited member. The new keyword is not required

#pragma warning disable CS0414 // The private field 'field' is assigned but its value is never used

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member 'Type_or_Member'

using DearImGui;
using DearImPlot;
using System;
using System.Collections.Concurrent;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using ImS8 = System.SByte;
using ImU8 = System.Byte;
using ImS16 = System.Int16;
using ImU16 = System.UInt16;
using ImS32 = System.Int32;
using ImU32 = System.UInt32;
using ImS64 = System.Int64;
using ImU64 = System.UInt64;

namespace DearImPlot
{
    /// <summary>Axis indices. The values assigned may change; NEVER hardcode these.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L116.</summary>
    // DEBUG: enum ImAxis_ {
    // DEBUG:     // horizontal axes
    // DEBUG:     ImAxis_X1 = 0, // enabled by default
    // DEBUG:     ImAxis_X2,     // disabled by default
    // DEBUG:     ImAxis_X3,     // disabled by default
    // DEBUG:     // vertical axes
    // DEBUG:     ImAxis_Y1,     // enabled by default
    // DEBUG:     ImAxis_Y2,     // disabled by default
    // DEBUG:     ImAxis_Y3,     // disabled by default
    // DEBUG:     // bookeeping
    // DEBUG:     ImAxis_COUNT
    // DEBUG: }
    public enum ImPlotAxis
    {
        /// <summary>Enabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L118.</summary>
        X1 = 0,
        /// <summary>Disabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L119.</summary>
        X2 = 1,
        /// <summary>Disabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L120.</summary>
        X3 = 2,
        /// <summary>Enabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L122.</summary>
        Y1 = 3,
        /// <summary>Disabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L123.</summary>
        Y2 = 4,
        /// <summary>Disabled by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L124.</summary>
        Y3 = 5,
    }

    /// <summary>Options for plots (see BeginPlot).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L130.</summary>
    // DEBUG: enum ImPlotFlags_ {
    // DEBUG:     ImPlotFlags_None          = 0,       // default
    // DEBUG:     ImPlotFlags_NoTitle       = 1 << 0,  // the plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MyPlot")
    // DEBUG:     ImPlotFlags_NoLegend      = 1 << 1,  // the legend will not be displayed
    // DEBUG:     ImPlotFlags_NoMouseText   = 1 << 2,  // the mouse position, in plot coordinates, will not be displayed inside of the plot
    // DEBUG:     ImPlotFlags_NoInputs      = 1 << 3,  // the user will not be able to interact with the plot
    // DEBUG:     ImPlotFlags_NoMenus       = 1 << 4,  // the user will not be able to open context menus
    // DEBUG:     ImPlotFlags_NoBoxSelect   = 1 << 5,  // the user will not be able to box-select
    // DEBUG:     ImPlotFlags_NoChild       = 1 << 6,  // a child window region will not be used to capture mouse scroll (can boost performance for single ImGui window applications)
    // DEBUG:     ImPlotFlags_NoFrame       = 1 << 7,  // the ImGui frame will not be rendered
    // DEBUG:     ImPlotFlags_Equal         = 1 << 8,  // x and y axes pairs will be constrained to have the same units/pixel
    // DEBUG:     ImPlotFlags_Crosshairs    = 1 << 9,  // the default mouse cursor will be replaced with a crosshair when hovered
    // DEBUG:     ImPlotFlags_CanvasOnly    = ImPlotFlags_NoTitle | ImPlotFlags_NoLegend | ImPlotFlags_NoMenus | ImPlotFlags_NoBoxSelect | ImPlotFlags_NoMouseText
    // DEBUG: }
    [Flags]
    public enum ImPlotFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L131.</summary>
        None = 0,
        /// <summary>The plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MyPlot").<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L132.</summary>
        NoTitle = 1,
        /// <summary>The legend will not be displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L133.</summary>
        NoLegend = 2,
        /// <summary>The mouse position, in plot coordinates, will not be displayed inside of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L134.</summary>
        NoMouseText = 4,
        /// <summary>The user will not be able to interact with the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L135.</summary>
        NoInputs = 8,
        /// <summary>The user will not be able to open context menus.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L136.</summary>
        NoMenus = 16,
        /// <summary>The user will not be able to box-select.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L137.</summary>
        NoBoxSelect = 32,
        /// <summary>A child window region will not be used to capture mouse scroll (can boost performance for single ImGui window applications).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L138.</summary>
        NoChild = 64,
        /// <summary>The ImGui frame will not be rendered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L139.</summary>
        NoFrame = 128,
        /// <summary>X and y axes pairs will be constrained to have the same units/pixel.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L140.</summary>
        Equal = 256,
        /// <summary>The default mouse cursor will be replaced with a crosshair when hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L141.</summary>
        Crosshairs = 512,
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L142.</summary>
        CanvasOnly = 55
    }

    /// <summary>Options for plot axes (see SetupAxis).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L146.</summary>
    // DEBUG: enum ImPlotAxisFlags_ {
    // DEBUG:     ImPlotAxisFlags_None          = 0,       // default
    // DEBUG:     ImPlotAxisFlags_NoLabel       = 1 << 0,  // the axis label will not be displayed (axis labels are also hidden if the supplied string name is NULL)
    // DEBUG:     ImPlotAxisFlags_NoGridLines   = 1 << 1,  // no grid lines will be displayed
    // DEBUG:     ImPlotAxisFlags_NoTickMarks   = 1 << 2,  // no tick marks will be displayed
    // DEBUG:     ImPlotAxisFlags_NoTickLabels  = 1 << 3,  // no text labels will be displayed
    // DEBUG:     ImPlotAxisFlags_NoInitialFit  = 1 << 4,  // axis will not be initially fit to data extents on the first rendered frame
    // DEBUG:     ImPlotAxisFlags_NoMenus       = 1 << 5,  // the user will not be able to open context menus with right-click
    // DEBUG:     ImPlotAxisFlags_NoSideSwitch  = 1 << 6,  // the user will not be able to switch the axis side by dragging it
    // DEBUG:     ImPlotAxisFlags_NoHighlight   = 1 << 7,  // the axis will not have its background highlighted when hovered or held
    // DEBUG:     ImPlotAxisFlags_Opposite      = 1 << 8,  // axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top)
    // DEBUG:     ImPlotAxisFlags_Foreground    = 1 << 9,  // grid lines will be displayed in the foreground (i.e. on top of data) instead of the background
    // DEBUG:     ImPlotAxisFlags_Invert        = 1 << 10, // the axis will be inverted
    // DEBUG:     ImPlotAxisFlags_AutoFit       = 1 << 11, // axis will be auto-fitting to data extents
    // DEBUG:     ImPlotAxisFlags_RangeFit      = 1 << 12, // axis will only fit points if the point is in the visible range of the **orthogonal** axis
    // DEBUG:     ImPlotAxisFlags_PanStretch    = 1 << 13, // panning in a locked or constrained state will cause the axis to stretch if possible
    // DEBUG:     ImPlotAxisFlags_LockMin       = 1 << 14, // the axis minimum value will be locked when panning/zooming
    // DEBUG:     ImPlotAxisFlags_LockMax       = 1 << 15, // the axis maximum value will be locked when panning/zooming
    // DEBUG:     ImPlotAxisFlags_Lock          = ImPlotAxisFlags_LockMin | ImPlotAxisFlags_LockMax,
    // DEBUG:     ImPlotAxisFlags_NoDecorations = ImPlotAxisFlags_NoLabel | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoTickMarks | ImPlotAxisFlags_NoTickLabels,
    // DEBUG:     ImPlotAxisFlags_AuxDefault    = ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_Opposite
    // DEBUG: }
    [Flags]
    public enum ImPlotAxisFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L147.</summary>
        None = 0,
        /// <summary>The axis label will not be displayed (axis labels are also hidden if the supplied string name is NULL).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L148.</summary>
        NoLabel = 1,
        /// <summary>No grid lines will be displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L149.</summary>
        NoGridLines = 2,
        /// <summary>No tick marks will be displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L150.</summary>
        NoTickMarks = 4,
        /// <summary>No text labels will be displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L151.</summary>
        NoTickLabels = 8,
        /// <summary>Axis will not be initially fit to data extents on the first rendered frame.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L152.</summary>
        NoInitialFit = 16,
        /// <summary>The user will not be able to open context menus with right-click.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L153.</summary>
        NoMenus = 32,
        /// <summary>The user will not be able to switch the axis side by dragging it.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L154.</summary>
        NoSideSwitch = 64,
        /// <summary>The axis will not have its background highlighted when hovered or held.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L155.</summary>
        NoHighlight = 128,
        /// <summary>Axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L156.</summary>
        Opposite = 256,
        /// <summary>Grid lines will be displayed in the foreground (i.e. on top of data) instead of the background.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L157.</summary>
        Foreground = 512,
        /// <summary>The axis will be inverted.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L158.</summary>
        Invert = 1024,
        /// <summary>Axis will be auto-fitting to data extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L159.</summary>
        AutoFit = 2048,
        /// <summary>Axis will only fit points if the point is in the visible range of the **orthogonal** axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L160.</summary>
        RangeFit = 4096,
        /// <summary>Panning in a locked or constrained state will cause the axis to stretch if possible.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L161.</summary>
        PanStretch = 8192,
        /// <summary>The axis minimum value will be locked when panning/zooming.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L162.</summary>
        LockMin = 16384,
        /// <summary>The axis maximum value will be locked when panning/zooming.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L163.</summary>
        LockMax = 32768,
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L164.</summary>
        Lock = 49152,
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L165.</summary>
        NoDecorations = 15,
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L166.</summary>
        AuxDefault = 258
    }

    /// <summary>Options for subplots (see BeginSubplot).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L170.</summary>
    // DEBUG: enum ImPlotSubplotFlags_ {
    // DEBUG:     ImPlotSubplotFlags_None        = 0,       // default
    // DEBUG:     ImPlotSubplotFlags_NoTitle     = 1 << 0,  // the subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MySubplot")
    // DEBUG:     ImPlotSubplotFlags_NoLegend    = 1 << 1,  // the legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled)
    // DEBUG:     ImPlotSubplotFlags_NoMenus     = 1 << 2,  // the user will not be able to open context menus with right-click
    // DEBUG:     ImPlotSubplotFlags_NoResize    = 1 << 3,  // resize splitters between subplot cells will be not be provided
    // DEBUG:     ImPlotSubplotFlags_NoAlign     = 1 << 4,  // subplot edges will not be aligned vertically or horizontally
    // DEBUG:     ImPlotSubplotFlags_ShareItems  = 1 << 5,  // items across all subplots will be shared and rendered into a single legend entry
    // DEBUG:     ImPlotSubplotFlags_LinkRows    = 1 << 6,  // link the y-axis limits of all plots in each row (does not apply to auxiliary axes)
    // DEBUG:     ImPlotSubplotFlags_LinkCols    = 1 << 7,  // link the x-axis limits of all plots in each column (does not apply to auxiliary axes)
    // DEBUG:     ImPlotSubplotFlags_LinkAllX    = 1 << 8,  // link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes)
    // DEBUG:     ImPlotSubplotFlags_LinkAllY    = 1 << 9,  // link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes)
    // DEBUG:     ImPlotSubplotFlags_ColMajor    = 1 << 10  // subplots are added in column major order instead of the default row major order
    // DEBUG: }
    [Flags]
    public enum ImPlotSubplotFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L171.</summary>
        None = 0,
        /// <summary>The subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MySubplot").<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L172.</summary>
        NoTitle = 1,
        /// <summary>The legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L173.</summary>
        NoLegend = 2,
        /// <summary>The user will not be able to open context menus with right-click.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L174.</summary>
        NoMenus = 4,
        /// <summary>Resize splitters between subplot cells will be not be provided.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L175.</summary>
        NoResize = 8,
        /// <summary>Subplot edges will not be aligned vertically or horizontally.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L176.</summary>
        NoAlign = 16,
        /// <summary>Items across all subplots will be shared and rendered into a single legend entry.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L177.</summary>
        ShareItems = 32,
        /// <summary>Link the y-axis limits of all plots in each row (does not apply to auxiliary axes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L178.</summary>
        LinkRows = 64,
        /// <summary>Link the x-axis limits of all plots in each column (does not apply to auxiliary axes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L179.</summary>
        LinkCols = 128,
        /// <summary>Link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L180.</summary>
        LinkAllX = 256,
        /// <summary>Link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L181.</summary>
        LinkAllY = 512,
        /// <summary>Subplots are added in column major order instead of the default row major order.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L182.</summary>
        ColMajor = 1024
    }

    /// <summary>Options for legends (see SetupLegend).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L186.</summary>
    // DEBUG: enum ImPlotLegendFlags_ {
    // DEBUG:     ImPlotLegendFlags_None            = 0,      // default
    // DEBUG:     ImPlotLegendFlags_NoButtons       = 1 << 0, // legend icons will not function as hide/show buttons
    // DEBUG:     ImPlotLegendFlags_NoHighlightItem = 1 << 1, // plot items will not be highlighted when their legend entry is hovered
    // DEBUG:     ImPlotLegendFlags_NoHighlightAxis = 1 << 2, // axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count > 1)
    // DEBUG:     ImPlotLegendFlags_NoMenus         = 1 << 3, // the user will not be able to open context menus with right-click
    // DEBUG:     ImPlotLegendFlags_Outside         = 1 << 4, // legend will be rendered outside of the plot area
    // DEBUG:     ImPlotLegendFlags_Horizontal      = 1 << 5, // legend entries will be displayed horizontally
    // DEBUG:     ImPlotLegendFlags_Sort            = 1 << 6, // legend entries will be displayed in alphabetical order
    // DEBUG: }
    [Flags]
    public enum ImPlotLegendFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L187.</summary>
        None = 0,
        /// <summary>Legend icons will not function as hide/show buttons.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L188.</summary>
        NoButtons = 1,
        /// <summary>Plot items will not be highlighted when their legend entry is hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L189.</summary>
        NoHighlightItem = 2,
        /// <summary>Axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count &gt; 1).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L190.</summary>
        NoHighlightAxis = 4,
        /// <summary>The user will not be able to open context menus with right-click.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L191.</summary>
        NoMenus = 8,
        /// <summary>Legend will be rendered outside of the plot area.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L192.</summary>
        Outside = 16,
        /// <summary>Legend entries will be displayed horizontally.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L193.</summary>
        Horizontal = 32,
        /// <summary>Legend entries will be displayed in alphabetical order.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L194.</summary>
        Sort = 64
    }

    /// <summary>Options for mouse hover text (see SetupMouseText).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L198.</summary>
    // DEBUG: enum ImPlotMouseTextFlags_ {
    // DEBUG:     ImPlotMouseTextFlags_None        = 0,      // default
    // DEBUG:     ImPlotMouseTextFlags_NoAuxAxes   = 1 << 0, // only show the mouse position for primary axes
    // DEBUG:     ImPlotMouseTextFlags_NoFormat    = 1 << 1, // axes label formatters won't be used to render text
    // DEBUG:     ImPlotMouseTextFlags_ShowAlways  = 1 << 2, // always display mouse position even if plot not hovered
    // DEBUG: }
    [Flags]
    public enum ImPlotMouseTextFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L199.</summary>
        None = 0,
        /// <summary>Only show the mouse position for primary axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L200.</summary>
        NoAuxAxes = 1,
        /// <summary>Axes label formatters won't be used to render text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L201.</summary>
        NoFormat = 2,
        /// <summary>Always display mouse position even if plot not hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L202.</summary>
        ShowAlways = 4
    }

    /// <summary>Options for DragPoint, DragLine, DragRect.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L206.</summary>
    // DEBUG: enum ImPlotDragToolFlags_ {
    // DEBUG:     ImPlotDragToolFlags_None      = 0,      // default
    // DEBUG:     ImPlotDragToolFlags_NoCursors = 1 << 0, // drag tools won't change cursor icons when hovered or held
    // DEBUG:     ImPlotDragToolFlags_NoFit     = 1 << 1, // the drag tool won't be considered for plot fits
    // DEBUG:     ImPlotDragToolFlags_NoInputs  = 1 << 2, // lock the tool from user inputs
    // DEBUG:     ImPlotDragToolFlags_Delayed   = 1 << 3, // tool rendering will be delayed one frame; useful when applying position-constraints
    // DEBUG: }
    [Flags]
    public enum ImPlotDragToolFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L207.</summary>
        None = 0,
        /// <summary>Drag tools won't change cursor icons when hovered or held.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L208.</summary>
        NoCursors = 1,
        /// <summary>The drag tool won't be considered for plot fits.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L209.</summary>
        NoFit = 2,
        /// <summary>Lock the tool from user inputs.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L210.</summary>
        NoInputs = 4,
        /// <summary>Tool rendering will be delayed one frame; useful when applying position-constraints.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L211.</summary>
        Delayed = 8
    }

    /// <summary>Flags for ColormapScale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L215.</summary>
    // DEBUG: enum ImPlotColormapScaleFlags_ {
    // DEBUG:     ImPlotColormapScaleFlags_None     = 0,      // default
    // DEBUG:     ImPlotColormapScaleFlags_NoLabel  = 1 << 0, // the colormap axis label will not be displayed
    // DEBUG:     ImPlotColormapScaleFlags_Opposite = 1 << 1, // render the colormap label and tick labels on the opposite side
    // DEBUG:     ImPlotColormapScaleFlags_Invert   = 1 << 2, // invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min > scale_max)
    // DEBUG: }
    [Flags]
    public enum ImPlotColormapScaleFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L216.</summary>
        None = 0,
        /// <summary>The colormap axis label will not be displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L217.</summary>
        NoLabel = 1,
        /// <summary>Render the colormap label and tick labels on the opposite side.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L218.</summary>
        Opposite = 2,
        /// <summary>Invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min &gt; scale_max).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L219.</summary>
        Invert = 4
    }

    /// <summary>Flags for ANY PlotX function.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L223.</summary>
    // DEBUG: enum ImPlotItemFlags_ {
    // DEBUG:     ImPlotItemFlags_None     = 0,
    // DEBUG:     ImPlotItemFlags_NoLegend = 1 << 0, // the item won't have a legend entry displayed
    // DEBUG:     ImPlotItemFlags_NoFit    = 1 << 1, // the item won't be considered for plot fits
    // DEBUG: }
    [Flags]
    public enum ImPlotItemFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L224.</summary>
        None = 0,
        /// <summary>The item won't have a legend entry displayed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L225.</summary>
        NoLegend = 1,
        /// <summary>The item won't be considered for plot fits.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L226.</summary>
        NoFit = 2
    }

    /// <summary>Flags for PlotLine.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L230.</summary>
    // DEBUG: enum ImPlotLineFlags_ {
    // DEBUG:     ImPlotLineFlags_None        = 0,       // default
    // DEBUG:     ImPlotLineFlags_Segments    = 1 << 10, // a line segment will be rendered from every two consecutive points
    // DEBUG:     ImPlotLineFlags_Loop        = 1 << 11, // the last and first point will be connected to form a closed loop
    // DEBUG:     ImPlotLineFlags_SkipNaN     = 1 << 12, // NaNs values will be skipped instead of rendered as missing data
    // DEBUG:     ImPlotLineFlags_NoClip      = 1 << 13, // markers (if displayed) on the edge of a plot will not be clipped
    // DEBUG:     ImPlotLineFlags_Shaded      = 1 << 14, // a filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases
    // DEBUG: }
    [Flags]
    public enum ImPlotLineFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L231.</summary>
        None = 0,
        /// <summary>A line segment will be rendered from every two consecutive points.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L232.</summary>
        Segments = 1024,
        /// <summary>The last and first point will be connected to form a closed loop.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L233.</summary>
        Loop = 2048,
        /// <summary>NaNs values will be skipped instead of rendered as missing data.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L234.</summary>
        SkipNaN = 4096,
        /// <summary>Markers (if displayed) on the edge of a plot will not be clipped.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L235.</summary>
        NoClip = 8192,
        /// <summary>A filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L236.</summary>
        Shaded = 16384
    }

    /// <summary>Flags for PlotScatter.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L240.</summary>
    // DEBUG: enum ImPlotScatterFlags_ {
    // DEBUG:     ImPlotScatterFlags_None   = 0,       // default
    // DEBUG:     ImPlotScatterFlags_NoClip = 1 << 10, // markers on the edge of a plot will not be clipped
    // DEBUG: }
    [Flags]
    public enum ImPlotScatterFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L241.</summary>
        None = 0,
        /// <summary>Markers on the edge of a plot will not be clipped.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L242.</summary>
        NoClip = 1024
    }

    /// <summary>Flags for PlotStairs.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L246.</summary>
    // DEBUG: enum ImPlotStairsFlags_ {
    // DEBUG:     ImPlotStairsFlags_None     = 0,       // default
    // DEBUG:     ImPlotStairsFlags_PreStep  = 1 << 10, // the y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]
    // DEBUG:     ImPlotStairsFlags_Shaded   = 1 << 11  // a filled region between the stairs and horizontal origin will be rendered; use PlotShaded for more advanced cases
    // DEBUG: }
    [Flags]
    public enum ImPlotStairsFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L247.</summary>
        None = 0,
        /// <summary>The y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L248.</summary>
        PreStep = 1024,
        /// <summary>A filled region between the stairs and horizontal origin will be rendered; use PlotShaded for more advanced cases.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L249.</summary>
        Shaded = 2048
    }

    /// <summary>Flags for PlotShaded (placeholder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L253.</summary>
    // DEBUG: enum ImPlotShadedFlags_ {
    // DEBUG:     ImPlotShadedFlags_None  = 0 // default
    // DEBUG: }
    [Flags]
    public enum ImPlotShadedFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L254.</summary>
        None = 0
    }

    /// <summary>Flags for PlotBars.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L258.</summary>
    // DEBUG: enum ImPlotBarsFlags_ {
    // DEBUG:     ImPlotBarsFlags_None         = 0,       // default
    // DEBUG:     ImPlotBarsFlags_Horizontal   = 1 << 10, // bars will be rendered horizontally on the current y-axis
    // DEBUG: }
    [Flags]
    public enum ImPlotBarsFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L259.</summary>
        None = 0,
        /// <summary>Bars will be rendered horizontally on the current y-axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L260.</summary>
        Horizontal = 1024
    }

    /// <summary>Flags for PlotBarGroups.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L264.</summary>
    // DEBUG: enum ImPlotBarGroupsFlags_ {
    // DEBUG:     ImPlotBarGroupsFlags_None        = 0,       // default
    // DEBUG:     ImPlotBarGroupsFlags_Horizontal  = 1 << 10, // bar groups will be rendered horizontally on the current y-axis
    // DEBUG:     ImPlotBarGroupsFlags_Stacked     = 1 << 11, // items in a group will be stacked on top of each other
    // DEBUG: }
    [Flags]
    public enum ImPlotBarGroupsFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L265.</summary>
        None = 0,
        /// <summary>Bar groups will be rendered horizontally on the current y-axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L266.</summary>
        Horizontal = 1024,
        /// <summary>Items in a group will be stacked on top of each other.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L267.</summary>
        Stacked = 2048
    }

    /// <summary>Flags for PlotErrorBars.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L271.</summary>
    // DEBUG: enum ImPlotErrorBarsFlags_ {
    // DEBUG:     ImPlotErrorBarsFlags_None       = 0,       // default
    // DEBUG:     ImPlotErrorBarsFlags_Horizontal = 1 << 10, // error bars will be rendered horizontally on the current y-axis
    // DEBUG: }
    [Flags]
    public enum ImPlotErrorBarsFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L272.</summary>
        None = 0,
        /// <summary>Error bars will be rendered horizontally on the current y-axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L273.</summary>
        Horizontal = 1024
    }

    /// <summary>Flags for PlotStems.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L277.</summary>
    // DEBUG: enum ImPlotStemsFlags_ {
    // DEBUG:     ImPlotStemsFlags_None       = 0,       // default
    // DEBUG:     ImPlotStemsFlags_Horizontal = 1 << 10, // stems will be rendered horizontally on the current y-axis
    // DEBUG: }
    [Flags]
    public enum ImPlotStemsFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L278.</summary>
        None = 0,
        /// <summary>Stems will be rendered horizontally on the current y-axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L279.</summary>
        Horizontal = 1024
    }

    /// <summary>Flags for PlotInfLines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L283.</summary>
    // DEBUG: enum ImPlotInfLinesFlags_ {
    // DEBUG:     ImPlotInfLinesFlags_None       = 0,      // default
    // DEBUG:     ImPlotInfLinesFlags_Horizontal = 1 << 10 // lines will be rendered horizontally on the current y-axis
    // DEBUG: }
    [Flags]
    public enum ImPlotInfLinesFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L284.</summary>
        None = 0,
        /// <summary>Lines will be rendered horizontally on the current y-axis.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L285.</summary>
        Horizontal = 1024
    }

    /// <summary>Flags for PlotPieChart.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L289.</summary>
    // DEBUG: enum ImPlotPieChartFlags_ {
    // DEBUG:     ImPlotPieChartFlags_None      = 0,      // default
    // DEBUG:     ImPlotPieChartFlags_Normalize = 1 << 10 // force normalization of pie chart values (i.e. always make a full circle if sum < 0)
    // DEBUG: }
    [Flags]
    public enum ImPlotPieChartFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L290.</summary>
        None = 0,
        /// <summary>Force normalization of pie chart values (i.e. always make a full circle if sum &lt; 0).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L291.</summary>
        Normalize = 1024
    }

    /// <summary>Flags for PlotHeatmap.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L295.</summary>
    // DEBUG: enum ImPlotHeatmapFlags_ {
    // DEBUG:     ImPlotHeatmapFlags_None     = 0,       // default
    // DEBUG:     ImPlotHeatmapFlags_ColMajor = 1 << 10, // data will be read in column major order
    // DEBUG: }
    [Flags]
    public enum ImPlotHeatmapFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L296.</summary>
        None = 0,
        /// <summary>Data will be read in column major order.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L297.</summary>
        ColMajor = 1024
    }

    /// <summary>Flags for PlotHistogram and PlotHistogram2D.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L301.</summary>
    // DEBUG: enum ImPlotHistogramFlags_ {
    // DEBUG:     ImPlotHistogramFlags_None       = 0,       // default
    // DEBUG:     ImPlotHistogramFlags_Horizontal = 1 << 10, // histogram bars will be rendered horizontally (not supported by PlotHistogram2D)
    // DEBUG:     ImPlotHistogramFlags_Cumulative = 1 << 11, // each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D)
    // DEBUG:     ImPlotHistogramFlags_Density    = 1 << 12, // counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set
    // DEBUG:     ImPlotHistogramFlags_NoOutliers = 1 << 13, // exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts
    // DEBUG:     ImPlotHistogramFlags_ColMajor   = 1 << 14  // data will be read in column major order (not supported by PlotHistogram)
    // DEBUG: }
    [Flags]
    public enum ImPlotHistogramFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L302.</summary>
        None = 0,
        /// <summary>Histogram bars will be rendered horizontally (not supported by PlotHistogram2D).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L303.</summary>
        Horizontal = 1024,
        /// <summary>Each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L304.</summary>
        Cumulative = 2048,
        /// <summary>Counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L305.</summary>
        Density = 4096,
        /// <summary>Exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L306.</summary>
        NoOutliers = 8192,
        /// <summary>Data will be read in column major order (not supported by PlotHistogram).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L307.</summary>
        ColMajor = 16384
    }

    /// <summary>Flags for PlotDigital (placeholder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L311.</summary>
    // DEBUG: enum ImPlotDigitalFlags_ {
    // DEBUG:     ImPlotDigitalFlags_None = 0 // default
    // DEBUG: }
    [Flags]
    public enum ImPlotDigitalFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L312.</summary>
        None = 0
    }

    /// <summary>Flags for PlotImage (placeholder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L316.</summary>
    // DEBUG: enum ImPlotImageFlags_ {
    // DEBUG:     ImPlotImageFlags_None = 0 // default
    // DEBUG: }
    [Flags]
    public enum ImPlotImageFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L317.</summary>
        None = 0
    }

    /// <summary>Flags for PlotText.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L321.</summary>
    // DEBUG: enum ImPlotTextFlags_ {
    // DEBUG:     ImPlotTextFlags_None     = 0,       // default
    // DEBUG:     ImPlotTextFlags_Vertical = 1 << 10  // text will be rendered vertically
    // DEBUG: }
    [Flags]
    public enum ImPlotTextFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L322.</summary>
        None = 0,
        /// <summary>Text will be rendered vertically.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L323.</summary>
        Vertical = 1024
    }

    /// <summary>Flags for PlotDummy (placeholder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L327.</summary>
    // DEBUG: enum ImPlotDummyFlags_ {
    // DEBUG:     ImPlotDummyFlags_None = 0 // default
    // DEBUG: }
    [Flags]
    public enum ImPlotDummyFlags
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L328.</summary>
        None = 0
    }

    /// <summary>Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L332.</summary>
    // DEBUG: enum ImPlotCond_
    // DEBUG: {
    // DEBUG:     ImPlotCond_None   = ImGuiCond_None,    // No condition (always set the variable), same as _Always
    // DEBUG:     ImPlotCond_Always = ImGuiCond_Always,  // No condition (always set the variable)
    // DEBUG:     ImPlotCond_Once   = ImGuiCond_Once,    // Set the variable once per runtime session (only the first call will succeed)
    // DEBUG: }
    public enum ImPlotCond
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L334.</summary>
        None = 0,
        /// <summary>No condition (always set the variable).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L335.</summary>
        Always = 1,
        /// <summary>Set the variable once per runtime session (only the first call will succeed).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L336.</summary>
        Once = 2
    }

    /// <summary>Plot styling colors.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L340.</summary>
    // DEBUG: enum ImPlotCol_ {
    // DEBUG:     // item styling colors
    // DEBUG:     ImPlotCol_Line,          // plot line/outline color (defaults to next unused color in current colormap)
    // DEBUG:     ImPlotCol_Fill,          // plot fill color for bars (defaults to the current line color)
    // DEBUG:     ImPlotCol_MarkerOutline, // marker outline color (defaults to the current line color)
    // DEBUG:     ImPlotCol_MarkerFill,    // marker fill color (defaults to the current line color)
    // DEBUG:     ImPlotCol_ErrorBar,      // error bar color (defaults to ImGuiCol_Text)
    // DEBUG:     // plot styling colors
    // DEBUG:     ImPlotCol_FrameBg,       // plot frame background color (defaults to ImGuiCol_FrameBg)
    // DEBUG:     ImPlotCol_PlotBg,        // plot area background color (defaults to ImGuiCol_WindowBg)
    // DEBUG:     ImPlotCol_PlotBorder,    // plot area border color (defaults to ImGuiCol_Border)
    // DEBUG:     ImPlotCol_LegendBg,      // legend background color (defaults to ImGuiCol_PopupBg)
    // DEBUG:     ImPlotCol_LegendBorder,  // legend border color (defaults to ImPlotCol_PlotBorder)
    // DEBUG:     ImPlotCol_LegendText,    // legend text color (defaults to ImPlotCol_InlayText)
    // DEBUG:     ImPlotCol_TitleText,     // plot title text color (defaults to ImGuiCol_Text)
    // DEBUG:     ImPlotCol_InlayText,     // color of text appearing inside of plots (defaults to ImGuiCol_Text)
    // DEBUG:     ImPlotCol_AxisText,      // axis label and tick lables color (defaults to ImGuiCol_Text)
    // DEBUG:     ImPlotCol_AxisGrid,      // axis grid color (defaults to 25% ImPlotCol_AxisText)
    // DEBUG:     ImPlotCol_AxisTick,      // axis tick color (defaults to AxisGrid)
    // DEBUG:     ImPlotCol_AxisBg,        // background color of axis hover region (defaults to transparent)
    // DEBUG:     ImPlotCol_AxisBgHovered, // axis hover color (defaults to ImGuiCol_ButtonHovered)
    // DEBUG:     ImPlotCol_AxisBgActive,  // axis active color (defaults to ImGuiCol_ButtonActive)
    // DEBUG:     ImPlotCol_Selection,     // box-selection color (defaults to yellow)
    // DEBUG:     ImPlotCol_Crosshairs,    // crosshairs color (defaults to ImPlotCol_PlotBorder)
    // DEBUG:     ImPlotCol_COUNT
    // DEBUG: }
    public enum ImPlotCol
    {
        /// <summary>Plot line/outline color (defaults to next unused color in current colormap).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L342.</summary>
        Line = 0,
        /// <summary>Plot fill color for bars (defaults to the current line color).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L343.</summary>
        Fill = 1,
        /// <summary>Marker outline color (defaults to the current line color).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L344.</summary>
        MarkerOutline = 2,
        /// <summary>Marker fill color (defaults to the current line color).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L345.</summary>
        MarkerFill = 3,
        /// <summary>Error bar color (defaults to ImGuiCol_Text).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L346.</summary>
        ErrorBar = 4,
        /// <summary>Plot frame background color (defaults to ImGuiCol_FrameBg).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L348.</summary>
        FrameBg = 5,
        /// <summary>Plot area background color (defaults to ImGuiCol_WindowBg).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L349.</summary>
        PlotBg = 6,
        /// <summary>Plot area border color (defaults to ImGuiCol_Border).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L350.</summary>
        PlotBorder = 7,
        /// <summary>Legend background color (defaults to ImGuiCol_PopupBg).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L351.</summary>
        LegendBg = 8,
        /// <summary>Legend border color (defaults to ImPlotCol_PlotBorder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L352.</summary>
        LegendBorder = 9,
        /// <summary>Legend text color (defaults to ImPlotCol_InlayText).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L353.</summary>
        LegendText = 10,
        /// <summary>Plot title text color (defaults to ImGuiCol_Text).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L354.</summary>
        TitleText = 11,
        /// <summary>Color of text appearing inside of plots (defaults to ImGuiCol_Text).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L355.</summary>
        InlayText = 12,
        /// <summary>Axis label and tick lables color (defaults to ImGuiCol_Text).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L356.</summary>
        AxisText = 13,
        /// <summary>Axis grid color (defaults to 25% ImPlotCol_AxisText).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L357.</summary>
        AxisGrid = 14,
        /// <summary>Axis tick color (defaults to AxisGrid).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L358.</summary>
        AxisTick = 15,
        /// <summary>Background color of axis hover region (defaults to transparent).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L359.</summary>
        AxisBg = 16,
        /// <summary>Axis hover color (defaults to ImGuiCol_ButtonHovered).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L360.</summary>
        AxisBgHovered = 17,
        /// <summary>Axis active color (defaults to ImGuiCol_ButtonActive).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L361.</summary>
        AxisBgActive = 18,
        /// <summary>Box-selection color (defaults to yellow).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L362.</summary>
        Selection = 19,
        /// <summary>Crosshairs color (defaults to ImPlotCol_PlotBorder).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L363.</summary>
        Crosshairs = 20,
    }

    /// <summary>Plot styling variables.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L368.</summary>
    // DEBUG: enum ImPlotStyleVar_ {
    // DEBUG:     // item styling variables
    // DEBUG:     ImPlotStyleVar_LineWeight,         // float,  plot item line weight in pixels
    // DEBUG:     ImPlotStyleVar_Marker,             // int,    marker specification
    // DEBUG:     ImPlotStyleVar_MarkerSize,         // float,  marker size in pixels (roughly the marker's "radius")
    // DEBUG:     ImPlotStyleVar_MarkerWeight,       // float,  plot outline weight of markers in pixels
    // DEBUG:     ImPlotStyleVar_FillAlpha,          // float,  alpha modifier applied to all plot item fills
    // DEBUG:     ImPlotStyleVar_ErrorBarSize,       // float,  error bar whisker width in pixels
    // DEBUG:     ImPlotStyleVar_ErrorBarWeight,     // float,  error bar whisker weight in pixels
    // DEBUG:     ImPlotStyleVar_DigitalBitHeight,   // float,  digital channels bit height (at 1) in pixels
    // DEBUG:     ImPlotStyleVar_DigitalBitGap,      // float,  digital channels bit padding gap in pixels
    // DEBUG:     // plot styling variables
    // DEBUG:     ImPlotStyleVar_PlotBorderSize,     // float,  thickness of border around plot area
    // DEBUG:     ImPlotStyleVar_MinorAlpha,         // float,  alpha multiplier applied to minor axis grid lines
    // DEBUG:     ImPlotStyleVar_MajorTickLen,       // ImVec2, major tick lengths for X and Y axes
    // DEBUG:     ImPlotStyleVar_MinorTickLen,       // ImVec2, minor tick lengths for X and Y axes
    // DEBUG:     ImPlotStyleVar_MajorTickSize,      // ImVec2, line thickness of major ticks
    // DEBUG:     ImPlotStyleVar_MinorTickSize,      // ImVec2, line thickness of minor ticks
    // DEBUG:     ImPlotStyleVar_MajorGridSize,      // ImVec2, line thickness of major grid lines
    // DEBUG:     ImPlotStyleVar_MinorGridSize,      // ImVec2, line thickness of minor grid lines
    // DEBUG:     ImPlotStyleVar_PlotPadding,        // ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
    // DEBUG:     ImPlotStyleVar_LabelPadding,       // ImVec2, padding between axes labels, tick labels, and plot edge
    // DEBUG:     ImPlotStyleVar_LegendPadding,      // ImVec2, legend padding from plot edges
    // DEBUG:     ImPlotStyleVar_LegendInnerPadding, // ImVec2, legend inner padding from legend edges
    // DEBUG:     ImPlotStyleVar_LegendSpacing,      // ImVec2, spacing between legend entries
    // DEBUG:     ImPlotStyleVar_MousePosPadding,    // ImVec2, padding between plot edge and interior info text
    // DEBUG:     ImPlotStyleVar_AnnotationPadding,  // ImVec2, text padding around annotation labels
    // DEBUG:     ImPlotStyleVar_FitPadding,         // ImVec2, additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)
    // DEBUG:     ImPlotStyleVar_PlotDefaultSize,    // ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot
    // DEBUG:     ImPlotStyleVar_PlotMinSize,        // ImVec2, minimum size plot frame can be when shrunk
    // DEBUG:     ImPlotStyleVar_COUNT
    // DEBUG: }
    public enum ImPlotStyleVar
    {
        /// <summary>Float,.<br/>Plot item line weight in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L370.</summary>
        LineWeight = 0,
        /// <summary>Int,.<br/>Marker specification.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L371.</summary>
        Marker = 1,
        /// <summary>Float,.<br/>Marker size in pixels (roughly the marker's "radius").<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L372.</summary>
        MarkerSize = 2,
        /// <summary>Float,.<br/>Plot outline weight of markers in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L373.</summary>
        MarkerWeight = 3,
        /// <summary>Float,.<br/>Alpha modifier applied to all plot item fills.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L374.</summary>
        FillAlpha = 4,
        /// <summary>Float,.<br/>Error bar whisker width in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L375.</summary>
        ErrorBarSize = 5,
        /// <summary>Float,.<br/>Error bar whisker weight in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L376.</summary>
        ErrorBarWeight = 6,
        /// <summary>Float,.<br/>Digital channels bit height (at 1) in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L377.</summary>
        DigitalBitHeight = 7,
        /// <summary>Float,.<br/>Digital channels bit padding gap in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L378.</summary>
        DigitalBitGap = 8,
        /// <summary>Float,.<br/>Thickness of border around plot area.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L380.</summary>
        PlotBorderSize = 9,
        /// <summary>Float,.<br/>Alpha multiplier applied to minor axis grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L381.</summary>
        MinorAlpha = 10,
        /// <summary>ImVec2, major tick lengths for X and Y axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L382.</summary>
        MajorTickLen = 11,
        /// <summary>ImVec2, minor tick lengths for X and Y axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L383.</summary>
        MinorTickLen = 12,
        /// <summary>ImVec2, line thickness of major ticks.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L384.</summary>
        MajorTickSize = 13,
        /// <summary>ImVec2, line thickness of minor ticks.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L385.</summary>
        MinorTickSize = 14,
        /// <summary>ImVec2, line thickness of major grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L386.</summary>
        MajorGridSize = 15,
        /// <summary>ImVec2, line thickness of minor grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L387.</summary>
        MinorGridSize = 16,
        /// <summary>ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L388.</summary>
        PlotPadding = 17,
        /// <summary>ImVec2, padding between axes labels, tick labels, and plot edge.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L389.</summary>
        LabelPadding = 18,
        /// <summary>ImVec2, legend padding from plot edges.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L390.</summary>
        LegendPadding = 19,
        /// <summary>ImVec2, legend inner padding from legend edges.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L391.</summary>
        LegendInnerPadding = 20,
        /// <summary>ImVec2, spacing between legend entries.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L392.</summary>
        LegendSpacing = 21,
        /// <summary>ImVec2, padding between plot edge and interior info text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L393.</summary>
        MousePosPadding = 22,
        /// <summary>ImVec2, text padding around annotation labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L394.</summary>
        AnnotationPadding = 23,
        /// <summary>ImVec2, additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L395.</summary>
        FitPadding = 24,
        /// <summary>ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L396.</summary>
        PlotDefaultSize = 25,
        /// <summary>ImVec2, minimum size plot frame can be when shrunk.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L397.</summary>
        PlotMinSize = 26,
    }

    /// <summary>Axis scale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L402.</summary>
    // DEBUG: enum ImPlotScale_ {
    // DEBUG:     ImPlotScale_Linear = 0, // default linear scale
    // DEBUG:     ImPlotScale_Time,       // date/time scale
    // DEBUG:     ImPlotScale_Log10,      // base 10 logartithmic scale
    // DEBUG:     ImPlotScale_SymLog,     // symmetric log scale
    // DEBUG: }
    public enum ImPlotScale
    {
        /// <summary>Default linear scale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L403.</summary>
        Linear = 0,
        /// <summary>Date/time scale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L404.</summary>
        Time = 1,
        /// <summary>Base 10 logartithmic scale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L405.</summary>
        Log10 = 2,
        /// <summary>Symmetric log scale.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L406.</summary>
        SymLog = 3
    }

    /// <summary>Marker specifications.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L410.</summary>
    // DEBUG: enum ImPlotMarker_ {
    // DEBUG:     ImPlotMarker_None = -1, // no marker
    // DEBUG:     ImPlotMarker_Circle,    // a circle marker (default)
    // DEBUG:     ImPlotMarker_Square,    // a square maker
    // DEBUG:     ImPlotMarker_Diamond,   // a diamond marker
    // DEBUG:     ImPlotMarker_Up,        // an upward-pointing triangle marker
    // DEBUG:     ImPlotMarker_Down,      // an downward-pointing triangle marker
    // DEBUG:     ImPlotMarker_Left,      // an leftward-pointing triangle marker
    // DEBUG:     ImPlotMarker_Right,     // an rightward-pointing triangle marker
    // DEBUG:     ImPlotMarker_Cross,     // a cross marker (not fillable)
    // DEBUG:     ImPlotMarker_Plus,      // a plus marker (not fillable)
    // DEBUG:     ImPlotMarker_Asterisk,  // a asterisk marker (not fillable)
    // DEBUG:     ImPlotMarker_COUNT
    // DEBUG: }
    public enum ImPlotMarker
    {
        /// <summary>Use the default behavior.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L411.</summary>
        None = -1,
        /// <summary>A circle marker (default).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L412.</summary>
        Circle = 0,
        /// <summary>A square maker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L413.</summary>
        Square = 1,
        /// <summary>A diamond marker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L414.</summary>
        Diamond = 2,
        /// <summary>An upward-pointing triangle marker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L415.</summary>
        Up = 3,
        /// <summary>An downward-pointing triangle marker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L416.</summary>
        Down = 4,
        /// <summary>An leftward-pointing triangle marker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L417.</summary>
        Left = 5,
        /// <summary>An rightward-pointing triangle marker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L418.</summary>
        Right = 6,
        /// <summary>A cross marker (not fillable).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L419.</summary>
        Cross = 7,
        /// <summary>A plus marker (not fillable).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L420.</summary>
        Plus = 8,
        /// <summary>A asterisk marker (not fillable).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L421.</summary>
        Asterisk = 9,
    }

    /// <summary>Built-in colormaps.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L426.</summary>
    // DEBUG: enum ImPlotColormap_ {
    // DEBUG:     ImPlotColormap_Deep     = 0,   // a.k.a. seaborn deep             (qual=true,  n=10) (default)
    // DEBUG:     ImPlotColormap_Dark     = 1,   // a.k.a. matplotlib "Set1"        (qual=true,  n=9 )
    // DEBUG:     ImPlotColormap_Pastel   = 2,   // a.k.a. matplotlib "Pastel1"     (qual=true,  n=9 )
    // DEBUG:     ImPlotColormap_Paired   = 3,   // a.k.a. matplotlib "Paired"      (qual=true,  n=12)
    // DEBUG:     ImPlotColormap_Viridis  = 4,   // a.k.a. matplotlib "viridis"     (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Plasma   = 5,   // a.k.a. matplotlib "plasma"      (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Hot      = 6,   // a.k.a. matplotlib/MATLAB "hot"  (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Cool     = 7,   // a.k.a. matplotlib/MATLAB "cool" (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Pink     = 8,   // a.k.a. matplotlib/MATLAB "pink" (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Jet      = 9,   // a.k.a. MATLAB "jet"             (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Twilight = 10,  // a.k.a. matplotlib "twilight"    (qual=false, n=11)
    // DEBUG:     ImPlotColormap_RdBu     = 11,  // red/blue, Color Brewer          (qual=false, n=11)
    // DEBUG:     ImPlotColormap_BrBG     = 12,  // brown/blue-green, Color Brewer  (qual=false, n=11)
    // DEBUG:     ImPlotColormap_PiYG     = 13,  // pink/yellow-green, Color Brewer (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Spectral = 14,  // color spectrum, Color Brewer    (qual=false, n=11)
    // DEBUG:     ImPlotColormap_Greys    = 15,  // white/black                     (qual=false, n=2 )
    // DEBUG: }
    public enum ImPlotColormap
    {
        /// <summary>A.k.a. seaborn deep.<br/>(qual=true,.<br/>N=10) (default).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L427.</summary>
        Deep = 0,
        /// <summary>A.k.a. matplotlib "Set1".<br/>(qual=true,.<br/>N=9 ).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L428.</summary>
        Dark = 1,
        /// <summary>A.k.a. matplotlib "Pastel1".<br/>(qual=true,.<br/>N=9 ).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L429.</summary>
        Pastel = 2,
        /// <summary>A.k.a. matplotlib "Paired".<br/>(qual=true,.<br/>N=12).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L430.</summary>
        Paired = 3,
        /// <summary>A.k.a. matplotlib "viridis".<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L431.</summary>
        Viridis = 4,
        /// <summary>A.k.a. matplotlib "plasma".<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L432.</summary>
        Plasma = 5,
        /// <summary>A.k.a. matplotlib/MATLAB "hot".<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L433.</summary>
        Hot = 6,
        /// <summary>A.k.a. matplotlib/MATLAB "cool" (qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L434.</summary>
        Cool = 7,
        /// <summary>A.k.a. matplotlib/MATLAB "pink" (qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L435.</summary>
        Pink = 8,
        /// <summary>A.k.a. MATLAB "jet".<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L436.</summary>
        Jet = 9,
        /// <summary>A.k.a. matplotlib "twilight".<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L437.</summary>
        Twilight = 10,
        /// <summary>Red/blue, Color Brewer.<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L438.</summary>
        RdBu = 11,
        /// <summary>Brown/blue-green, Color Brewer.<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L439.</summary>
        BrBG = 12,
        /// <summary>Pink/yellow-green, Color Brewer (qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L440.</summary>
        PiYG = 13,
        /// <summary>Color spectrum, Color Brewer.<br/>(qual=false, n=11).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L441.</summary>
        Spectral = 14,
        /// <summary>White/black.<br/>(qual=false, n=2 ).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L442.</summary>
        Greys = 15
    }

    /// <summary>Used to position items on a plot (e.g. legends, labels, etc.).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L446.</summary>
    // DEBUG: enum ImPlotLocation_ {
    // DEBUG:     ImPlotLocation_Center    = 0,                                          // center-center
    // DEBUG:     ImPlotLocation_North     = 1 << 0,                                     // top-center
    // DEBUG:     ImPlotLocation_South     = 1 << 1,                                     // bottom-center
    // DEBUG:     ImPlotLocation_West      = 1 << 2,                                     // center-left
    // DEBUG:     ImPlotLocation_East      = 1 << 3,                                     // center-right
    // DEBUG:     ImPlotLocation_NorthWest = ImPlotLocation_North | ImPlotLocation_West, // top-left
    // DEBUG:     ImPlotLocation_NorthEast = ImPlotLocation_North | ImPlotLocation_East, // top-right
    // DEBUG:     ImPlotLocation_SouthWest = ImPlotLocation_South | ImPlotLocation_West, // bottom-left
    // DEBUG:     ImPlotLocation_SouthEast = ImPlotLocation_South | ImPlotLocation_East  // bottom-right
    // DEBUG: }
    public enum ImPlotLocation
    {
        /// <summary>Center-center.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L447.</summary>
        Center = 0,
        /// <summary>Top-center.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L448.</summary>
        North = 1,
        /// <summary>Bottom-center.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L449.</summary>
        South = 2,
        /// <summary>Center-left.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L450.</summary>
        West = 4,
        /// <summary>Center-right.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L451.</summary>
        East = 8,
        /// <summary>Top-left.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L452.</summary>
        NorthWest = 5,
        /// <summary>Top-right.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L453.</summary>
        NorthEast = 9,
        /// <summary>Bottom-left.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L454.</summary>
        SouthWest = 6,
        /// <summary>Bottom-right.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L455.</summary>
        SouthEast = 10
    }

    /// <summary>Enums for different automatic histogram binning methods (k = bin count or w = bin width).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L459.</summary>
    // DEBUG: enum ImPlotBin_ {
    // DEBUG:     ImPlotBin_Sqrt    = -1, // k = sqrt(n)
    // DEBUG:     ImPlotBin_Sturges = -2, // k = 1 + log2(n)
    // DEBUG:     ImPlotBin_Rice    = -3, // k = 2 * cbrt(n)
    // DEBUG:     ImPlotBin_Scott   = -4, // w = 3.49 * sigma / cbrt(n)
    // DEBUG: }
    public enum ImPlotBin
    {
        /// <summary>K = sqrt(n).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L460.</summary>
        Sqrt = -1,
        /// <summary>K = 1 + log2(n).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L461.</summary>
        Sturges = -2,
        /// <summary>K = 2 * cbrt(n).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L462.</summary>
        Rice = -3,
        /// <summary>W = 3.49 * sigma / cbrt(n).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L463.</summary>
        Scott = -4
    }

    // DEBUG: typedef int ImAxis
    // DEBUG: typedef int ImPlotFlags
    // DEBUG: typedef int ImPlotAxisFlags
    // DEBUG: typedef int ImPlotSubplotFlags
    // DEBUG: typedef int ImPlotLegendFlags
    // DEBUG: typedef int ImPlotMouseTextFlags
    // DEBUG: typedef int ImPlotDragToolFlags
    // DEBUG: typedef int ImPlotColormapScaleFlags
    // DEBUG: typedef int ImPlotItemFlags
    // DEBUG: typedef int ImPlotLineFlags
    // DEBUG: typedef int ImPlotScatterFlags
    // DEBUG: typedef int ImPlotStairsFlags
    // DEBUG: typedef int ImPlotShadedFlags
    // DEBUG: typedef int ImPlotBarsFlags
    // DEBUG: typedef int ImPlotBarGroupsFlags
    // DEBUG: typedef int ImPlotErrorBarsFlags
    // DEBUG: typedef int ImPlotStemsFlags
    // DEBUG: typedef int ImPlotInfLinesFlags
    // DEBUG: typedef int ImPlotPieChartFlags
    // DEBUG: typedef int ImPlotHeatmapFlags
    // DEBUG: typedef int ImPlotHistogramFlags
    // DEBUG: typedef int ImPlotDigitalFlags
    // DEBUG: typedef int ImPlotImageFlags
    // DEBUG: typedef int ImPlotTextFlags
    // DEBUG: typedef int ImPlotDummyFlags
    // DEBUG: typedef int ImPlotCond
    // DEBUG: typedef int ImPlotCol
    // DEBUG: typedef int ImPlotStyleVar
    // DEBUG: typedef int ImPlotScale
    // DEBUG: typedef int ImPlotMarker
    // DEBUG: typedef int ImPlotColormap
    // DEBUG: typedef int ImPlotLocation
    // DEBUG: typedef int ImPlotBin
    /// <summary>Callback signature for axis tick label formatter.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L577.</summary>
    // DEBUG: typedef int (*ImPlotFormatter)(double value, char* buff, int size, void* user_data)
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public unsafe delegate int ImPlotFormatter(double value, sbyte* buff, int size, IntPtr user_data);

    /// <summary>Callback signature for data getter.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L580.</summary>
    // DEBUG: typedef ImPlotPoint (*ImPlotGetter)(int idx, void* user_data)
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public unsafe delegate ImPlotPoint ImPlotGetter(int idx, IntPtr user_data);

    /// <summary>Callback signature for axis transform.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L583.</summary>
    // DEBUG: typedef double (*ImPlotTransform)(double value, void* user_data)
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public unsafe delegate double ImPlotTransform(double value, IntPtr user_data);

    /// <summary>ImPlot context (opaque struct, see implot_internal.h).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L76.</summary>
    // DEBUG: struct ImPlotContext
    public unsafe partial class ImPlotContext
    {
        internal partial struct __Internal
        {
        }

        internal IntPtr __Instance { get; set; }

        internal static readonly new ConcurrentDictionary<IntPtr, WeakReference<ImPlotContext>> NativeToManagedMap = new ConcurrentDictionary<IntPtr, WeakReference<ImPlotContext>>();
        internal static void __RecordNativeToManagedMapping(IntPtr native, ImPlotContext managed)
        {
            NativeToManagedMap[native] = new WeakReference<ImPlotContext>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out ImPlotContext managed)
        {
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private protected bool __ownsNativeInstance;
        internal static ImPlotContext __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotContext(native.ToPointer(), skipVTables);
        }

        internal static ImPlotContext __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPlotContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPlotContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private ImPlotContext(__Internal native, bool skipVTables = false) : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        private protected ImPlotContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }
    }

    /// <summary>Double precision version of ImVec2 used by ImPlot. Extensible by end users.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L467.</summary>
    // DEBUG: struct ImPlotPoint {
    // DEBUG:     double x, y;
    // DEBUG:     ImPlotPoint()                         { x = y = 0.0;      }
    // DEBUG:     ImPlotPoint(double _x, double _y)     { x = _x; y = _y;   }
    // DEBUG:     ImPlotPoint(const ImVec2& p)          { x = p.x; y = p.y; }
    // DEBUG:     double  operator[] (size_t idx) const { return (&x)[idx]; }
    // DEBUG:     double& operator[] (size_t idx)       { return (&x)[idx]; }
    // DEBUG: #ifdef IMPLOT_POINT_CLASS_EXTRA
    // DEBUG:     IMPLOT_POINT_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h
    // DEBUG:                                  // to convert back and forth between your math types and ImPlotPoint.
    // DEBUG: #endif
    // DEBUG: }
    public unsafe partial struct ImPlotPoint
    {
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Internal
        {
            internal double x;
            internal double y;
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QAE@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QAE@NN@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, double _x, double _y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QAE@ABUImVec2@@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QAE@$$QAU0@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor_1(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??AImPlotPoint@@QAEAANI@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern double* OperatorSubscript(IntPtr __instance, UIntPtr idx);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QEAA@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QEAA@NN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, double _x, double _y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QEAA@AEBUImVec2@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotPoint@@QEAA@$$QEAU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor_1(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??AImPlotPoint@@QEAAAEAN_K@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double* OperatorSubscript(IntPtr __instance, UIntPtr idx);

        }

        private ImPlotPoint.__Internal __instance;
        internal ImPlotPoint.__Internal __Instance => __instance;
        internal static ImPlotPoint __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotPoint(native.ToPointer(), skipVTables);
        }

        internal static ImPlotPoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotPoint(native, skipVTables);
        }

        private ImPlotPoint(__Internal native, bool skipVTables = false) : this()
        {
            __instance = native;
        }

        private ImPlotPoint(void* native, bool skipVTables = false) : this()
        {
            __instance = *(ImPlotPoint.__Internal*)native;
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L470.</summary>
        // DEBUG: ImPlotPoint(double _x, double _y)     { x = _x; y = _y;   }
        public ImPlotPoint(double _x, double _y) : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), _x, _y);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), _x, _y);
                }
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L471.</summary>
        // DEBUG: ImPlotPoint(const ImVec2& p)          { x = p.x; y = p.y; }
        public ImPlotPoint(Vector2 p) : this()
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref p))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), __arg0);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), __arg0);
                }
            }
        }

        /// <summary>Double precision version of ImVec2 used by ImPlot. Extensible by end users.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L467.</summary>
        // DEBUG: ImPlotPoint
        public ImPlotPoint(ImPlotPoint _0) : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor_1(new IntPtr(__instancePtr), __arg0);
                }
                else
                {
                    __Internal32.ctor_1(new IntPtr(__instancePtr), __arg0);
                }
            }
        }

        public static implicit operator ImPlotPoint(Vector2 p)
        {
            return new ImPlotPoint(p);
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L468.</summary>
        public double X
        {
            get
            {
                return __instance.x;
            }

            set
            {
                __instance.x = value;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L468.</summary>
        public double Y
        {
            get
            {
                return __instance.y;
            }

            set
            {
                __instance.y = value;
            }
        }
    }

    /// <summary>Range defined by a min/max value.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L481.</summary>
    // DEBUG: struct ImPlotRange {
    // DEBUG:     double Min, Max;
    // DEBUG:     ImPlotRange()                         { Min = 0; Max = 0;                                         }
    // DEBUG:     ImPlotRange(double _min, double _max) { Min = _min; Max = _max;                                   }
    // DEBUG:     bool Contains(double value) const     { return value >= Min && value <= Max;                      }
    // DEBUG:     double Size() const                   { return Max - Min;                                         }
    // DEBUG:     double Clamp(double value) const      { return (value < Min) ? Min : (value > Max) ? Max : value; }
    // DEBUG: }
    public unsafe partial struct ImPlotRange
    {
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Internal
        {
            internal double Min;
            internal double Max;
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QAE@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QAE@NN@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, double _min, double _max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QAE@$$QAU0@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRange@@QBE_NN@Z", CallingConvention = CallingConvention.ThisCall)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, double value);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRange@@QBENN@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern double Clamp(IntPtr __instance, double value);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Size@ImPlotRange@@QBENXZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern double Size(IntPtr __instance);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QEAA@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QEAA@NN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, double _min, double _max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRange@@QEAA@$$QEAU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRange@@QEBA_NN@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, double value);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRange@@QEBANN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double Clamp(IntPtr __instance, double value);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Size@ImPlotRange@@QEBANXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double Size(IntPtr __instance);

        }

        private ImPlotRange.__Internal __instance;
        internal ImPlotRange.__Internal __Instance => __instance;
        internal static ImPlotRange __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotRange(native.ToPointer(), skipVTables);
        }

        internal static ImPlotRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotRange(native, skipVTables);
        }

        private ImPlotRange(__Internal native, bool skipVTables = false) : this()
        {
            __instance = native;
        }

        private ImPlotRange(void* native, bool skipVTables = false) : this()
        {
            __instance = *(ImPlotRange.__Internal*)native;
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L484.</summary>
        // DEBUG: ImPlotRange(double _min, double _max) { Min = _min; Max = _max;                                   }
        public ImPlotRange(double _min, double _max) : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), _min, _max);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), _min, _max);
                }
            }
        }

        /// <summary>Range defined by a min/max value.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L481.</summary>
        // DEBUG: ImPlotRange
        public ImPlotRange(ImPlotRange _0) : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), __arg0);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), __arg0);
                }
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L485.</summary>
        // DEBUG: bool Contains(double value) const     { return value >= Min && value <= Max;                      }
        public bool Contains(double value)
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var ___ret = Environment.Is64BitProcess ? __Internal64.Contains(new IntPtr(__instancePtr), value) : __Internal32.Contains(new IntPtr(__instancePtr), value);
                return ___ret;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L487.</summary>
        // DEBUG: double Clamp(double value) const      { return (value < Min) ? Min : (value > Max) ? Max : value; }
        public double Clamp(double value)
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var ___ret = Environment.Is64BitProcess ? __Internal64.Clamp(new IntPtr(__instancePtr), value) : __Internal32.Clamp(new IntPtr(__instancePtr), value);
                return ___ret;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L482.</summary>
        public double Min
        {
            get
            {
                return __instance.Min;
            }

            set
            {
                __instance.Min = value;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L482.</summary>
        public double Max
        {
            get
            {
                return __instance.Max;
            }

            set
            {
                __instance.Max = value;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L486.</summary>
        public double Size
        {
            get
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var ___ret = Environment.Is64BitProcess ? __Internal64.Size(new IntPtr(__instancePtr)) : __Internal32.Size(new IntPtr(__instancePtr));
                    return ___ret;
                }
            }
        }
    }

    /// <summary>Combination of two range limits for X and Y axes. Also an AABB defined by Min()/Max().<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L491.</summary>
    // DEBUG: struct ImPlotRect {
    // DEBUG:     ImPlotRange X, Y;
    // DEBUG:     ImPlotRect()                                                       {                                                               }
    // DEBUG:     ImPlotRect(double x_min, double x_max, double y_min, double y_max) { X.Min = x_min; X.Max = x_max; Y.Min = y_min; Y.Max = y_max;   }
    // DEBUG:     bool Contains(const ImPlotPoint& p) const                          { return Contains(p.x, p.y);                                    }
    // DEBUG:     bool Contains(double x, double y) const                            { return X.Contains(x) && Y.Contains(y);                        }
    // DEBUG:     ImPlotPoint Size() const                                           { return ImPlotPoint(X.Size(), Y.Size());                       }
    // DEBUG:     ImPlotPoint Clamp(const ImPlotPoint& p)                            { return Clamp(p.x, p.y);                                       }
    // DEBUG:     ImPlotPoint Clamp(double x, double y)                              { return ImPlotPoint(X.Clamp(x),Y.Clamp(y));                    }
    // DEBUG:     ImPlotPoint Min() const                                            { return ImPlotPoint(X.Min, Y.Min);                             }
    // DEBUG:     ImPlotPoint Max() const                                            { return ImPlotPoint(X.Max, Y.Max);                             }
    // DEBUG: }
    public unsafe partial struct ImPlotRect
    {
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Internal
        {
            internal ImPlotRange.__Internal X;
            internal ImPlotRange.__Internal Y;
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QAE@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QAE@NNNN@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, double x_min, double x_max, double y_min, double y_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QAE@$$QAU0@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRect@@QBE_NABUImPlotPoint@@@Z", CallingConvention = CallingConvention.ThisCall)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRect@@QBE_NNN@Z", CallingConvention = CallingConvention.ThisCall)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRect@@QAE?AUImPlotPoint@@ABU2@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern void Clamp(IntPtr __instance, IntPtr @return, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRect@@QAE?AUImPlotPoint@@NN@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern void Clamp(IntPtr __instance, IntPtr @return, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Size@ImPlotRect@@QBE?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern void Size(IntPtr __instance, IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Min@ImPlotRect@@QBE?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern void Min(IntPtr __instance, IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Max@ImPlotRect@@QBE?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern void Max(IntPtr __instance, IntPtr @return);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QEAA@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QEAA@NNNN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, double x_min, double x_max, double y_min, double y_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotRect@@QEAA@$$QEAU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRect@@QEBA_NAEBUImPlotPoint@@@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Contains@ImPlotRect@@QEBA_NNN@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(IntPtr __instance, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRect@@QEAA?AUImPlotPoint@@AEBU2@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Clamp(IntPtr __instance, IntPtr @return, IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Clamp@ImPlotRect@@QEAA?AUImPlotPoint@@NN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Clamp(IntPtr __instance, IntPtr @return, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Size@ImPlotRect@@QEBA?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Size(IntPtr __instance, IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Min@ImPlotRect@@QEBA?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Min(IntPtr __instance, IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Max@ImPlotRect@@QEBA?AUImPlotPoint@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Max(IntPtr __instance, IntPtr @return);

        }

        private ImPlotRect.__Internal __instance;
        internal ImPlotRect.__Internal __Instance => __instance;
        internal static ImPlotRect __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotRect(native.ToPointer(), skipVTables);
        }

        internal static ImPlotRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotRect(native, skipVTables);
        }

        private ImPlotRect(__Internal native, bool skipVTables = false) : this()
        {
            __instance = native;
        }

        private ImPlotRect(void* native, bool skipVTables = false) : this()
        {
            __instance = *(ImPlotRect.__Internal*)native;
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L494.</summary>
        // DEBUG: ImPlotRect(double x_min, double x_max, double y_min, double y_max) { X.Min = x_min; X.Max = x_max; Y.Min = y_min; Y.Max = y_max;   }
        public ImPlotRect(double x_min, double x_max, double y_min, double y_max) : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), x_min, x_max, y_min, y_max);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), x_min, x_max, y_min, y_max);
                }
            }
        }

        /// <summary>Combination of two range limits for X and Y axes. Also an AABB defined by Min()/Max().<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L491.</summary>
        // DEBUG: ImPlotRect
        public ImPlotRect(ImPlotRect _0) : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), __arg0);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), __arg0);
                }
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L495.</summary>
        // DEBUG: bool Contains(const ImPlotPoint& p) const                          { return Contains(p.x, p.y);                                    }
        public bool Contains(ImPlotPoint p)
        {
            var ____arg0 = p.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                var ___ret = Environment.Is64BitProcess ? __Internal64.Contains(new IntPtr(__instancePtr), __arg0) : __Internal32.Contains(new IntPtr(__instancePtr), __arg0);
                return ___ret;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L496.</summary>
        // DEBUG: bool Contains(double x, double y) const                            { return X.Contains(x) && Y.Contains(y);                        }
        public bool Contains(double x, double y)
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var ___ret = Environment.Is64BitProcess ? __Internal64.Contains(new IntPtr(__instancePtr), x, y) : __Internal32.Contains(new IntPtr(__instancePtr), x, y);
                return ___ret;
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L498.</summary>
        // DEBUG: ImPlotPoint Clamp(const ImPlotPoint& p)                            { return Clamp(p.x, p.y);                                       }
        public ImPlotPoint Clamp(ImPlotPoint p)
        {
            var ____arg0 = p.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            var ___ret = new ImPlotPoint.__Internal();
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.Clamp(new IntPtr(__instancePtr), new IntPtr(&___ret), __arg0);
                }
                else
                {
                    __Internal32.Clamp(new IntPtr(__instancePtr), new IntPtr(&___ret), __arg0);
                }

                return ImPlotPoint.__CreateInstance(___ret);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L499.</summary>
        // DEBUG: ImPlotPoint Clamp(double x, double y)                              { return ImPlotPoint(X.Clamp(x),Y.Clamp(y));                    }
        public ImPlotPoint Clamp(double x, double y)
        {
            var ___ret = new ImPlotPoint.__Internal();
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.Clamp(new IntPtr(__instancePtr), new IntPtr(&___ret), x, y);
                }
                else
                {
                    __Internal32.Clamp(new IntPtr(__instancePtr), new IntPtr(&___ret), x, y);
                }

                return ImPlotPoint.__CreateInstance(___ret);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L492.</summary>
        // DEBUG: ImPlotRange X
        public ImPlotRange X;
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L492.</summary>
        // DEBUG: ImPlotRange X, Y
        public ImPlotRange Y;
        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L497.</summary>
        public ImPlotPoint Size
        {
            get
            {
                var ___ret = new ImPlotPoint.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.Size(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }
                    else
                    {
                        __Internal32.Size(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }

                    return ImPlotPoint.__CreateInstance(___ret);
                }
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L500.</summary>
        public ImPlotPoint Min
        {
            get
            {
                var ___ret = new ImPlotPoint.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.Min(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }
                    else
                    {
                        __Internal32.Min(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }

                    return ImPlotPoint.__CreateInstance(___ret);
                }
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L501.</summary>
        public ImPlotPoint Max
        {
            get
            {
                var ___ret = new ImPlotPoint.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.Max(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }
                    else
                    {
                        __Internal32.Max(new IntPtr(__instancePtr), new IntPtr(&___ret));
                    }

                    return ImPlotPoint.__CreateInstance(___ret);
                }
            }
        }
    }

    /// <summary>Plot style structure.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L505.</summary>
    // DEBUG: struct ImPlotStyle {
    // DEBUG:     // item styling variables
    // DEBUG:     float   LineWeight;              // = 1,      item line weight in pixels
    // DEBUG:     int     Marker;                  // = ImPlotMarker_None, marker specification
    // DEBUG:     float   MarkerSize;              // = 4,      marker size in pixels (roughly the marker's "radius")
    // DEBUG:     float   MarkerWeight;            // = 1,      outline weight of markers in pixels
    // DEBUG:     float   FillAlpha;               // = 1,      alpha modifier applied to plot fills
    // DEBUG:     float   ErrorBarSize;            // = 5,      error bar whisker width in pixels
    // DEBUG:     float   ErrorBarWeight;          // = 1.5,    error bar whisker weight in pixels
    // DEBUG:     float   DigitalBitHeight;        // = 8,      digital channels bit height (at y = 1.0f) in pixels
    // DEBUG:     float   DigitalBitGap;           // = 4,      digital channels bit padding gap in pixels
    // DEBUG:     // plot styling variables
    // DEBUG:     float   PlotBorderSize;          // = 1,      line thickness of border around plot area
    // DEBUG:     float   MinorAlpha;              // = 0.25    alpha multiplier applied to minor axis grid lines
    // DEBUG:     ImVec2  MajorTickLen;            // = 10,10   major tick lengths for X and Y axes
    // DEBUG:     ImVec2  MinorTickLen;            // = 5,5     minor tick lengths for X and Y axes
    // DEBUG:     ImVec2  MajorTickSize;           // = 1,1     line thickness of major ticks
    // DEBUG:     ImVec2  MinorTickSize;           // = 1,1     line thickness of minor ticks
    // DEBUG:     ImVec2  MajorGridSize;           // = 1,1     line thickness of major grid lines
    // DEBUG:     ImVec2  MinorGridSize;           // = 1,1     line thickness of minor grid lines
    // DEBUG:     ImVec2  PlotPadding;             // = 10,10   padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
    // DEBUG:     ImVec2  LabelPadding;            // = 5,5     padding between axes labels, tick labels, and plot edge
    // DEBUG:     ImVec2  LegendPadding;           // = 10,10   legend padding from plot edges
    // DEBUG:     ImVec2  LegendInnerPadding;      // = 5,5     legend inner padding from legend edges
    // DEBUG:     ImVec2  LegendSpacing;           // = 5,0     spacing between legend entries
    // DEBUG:     ImVec2  MousePosPadding;         // = 10,10   padding between plot edge and interior mouse location text
    // DEBUG:     ImVec2  AnnotationPadding;       // = 2,2     text padding around annotation labels
    // DEBUG:     ImVec2  FitPadding;              // = 0,0     additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)
    // DEBUG:     ImVec2  PlotDefaultSize;         // = 400,300 default size used when ImVec2(0,0) is passed to BeginPlot
    // DEBUG:     ImVec2  PlotMinSize;             // = 200,150 minimum size plot frame can be when shrunk
    // DEBUG:     // style colors
    // DEBUG:     ImVec4  Colors[ImPlotCol_COUNT]; // Array of styling colors. Indexable with ImPlotCol_ enums.
    // DEBUG:     // colormap
    // DEBUG:     ImPlotColormap Colormap;         // The current colormap. Set this to either an ImPlotColormap_ enum or an index returned by AddColormap.
    // DEBUG:     // settings/flags
    // DEBUG:     bool    UseLocalTime;            // = false,  axis labels will be formatted for your timezone when ImPlotAxisFlag_Time is enabled
    // DEBUG:     bool    UseISO8601;              // = false,  dates will be formatted according to ISO 8601 where applicable (e.g. YYYY-MM-DD, YYYY-MM, --MM-DD, etc.)
    // DEBUG:     bool    Use24HourClock;          // = false,  times will be formatted using a 24 hour clock
    // DEBUG:     IMPLOT_API ImPlotStyle();
    // DEBUG: }
    public unsafe partial class ImPlotStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Internal
        {
            internal float LineWeight;
            internal int Marker;
            internal float MarkerSize;
            internal float MarkerWeight;
            internal float FillAlpha;
            internal float ErrorBarSize;
            internal float ErrorBarWeight;
            internal float DigitalBitHeight;
            internal float DigitalBitGap;
            internal float PlotBorderSize;
            internal float MinorAlpha;
            internal Vector2 MajorTickLen;
            internal Vector2 MinorTickLen;
            internal Vector2 MajorTickSize;
            internal Vector2 MinorTickSize;
            internal Vector2 MajorGridSize;
            internal Vector2 MinorGridSize;
            internal Vector2 PlotPadding;
            internal Vector2 LabelPadding;
            internal Vector2 LegendPadding;
            internal Vector2 LegendInnerPadding;
            internal Vector2 LegendSpacing;
            internal Vector2 MousePosPadding;
            internal Vector2 AnnotationPadding;
            internal Vector2 FitPadding;
            internal Vector2 PlotDefaultSize;
            internal Vector2 PlotMinSize;
            internal fixed byte Colors[336];
            internal ImPlotColormap Colormap;
            internal byte UseLocalTime;
            internal byte UseISO8601;
            internal byte Use24HourClock;
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotStyle@@QAE@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotStyle@@QAE@$$QAU0@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotStyle@@QEAA@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotStyle@@QEAA@$$QEAU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

        }

        internal IntPtr __Instance { get; set; }

        internal static readonly new ConcurrentDictionary<IntPtr, WeakReference<ImPlotStyle>> NativeToManagedMap = new ConcurrentDictionary<IntPtr, WeakReference<ImPlotStyle>>();
        internal static void __RecordNativeToManagedMapping(IntPtr native, ImPlotStyle managed)
        {
            NativeToManagedMap[native] = new WeakReference<ImPlotStyle>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out ImPlotStyle managed)
        {
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private protected bool __ownsNativeInstance;
        internal static ImPlotStyle __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotStyle(native.ToPointer(), skipVTables);
        }

        internal static ImPlotStyle __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPlotStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPlotStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private ImPlotStyle(__Internal native, bool skipVTables = false) : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        private protected ImPlotStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L543.</summary>
        // DEBUG: ImPlotStyle()
        public ImPlotStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(ImPlotStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (Environment.Is64BitProcess)
            {
                __Internal64.ctor(__Instance);
            }
            else
            {
                __Internal32.ctor(__Instance);
            }
        }

        /// <summary>Plot style structure.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L505.</summary>
        // DEBUG: ImPlotStyle
        public ImPlotStyle(ImPlotStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(ImPlotStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.ctor(__Instance, __arg0);
            }
            else
            {
                __Internal32.ctor(__Instance, __arg0);
            }
        }

        /// <inheritdoc/>
        ~ImPlotStyle()
        {
            Dispose(false, callNativeDtor: __ownsNativeInstance);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);
        private protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>= 1,.<br/>Item line weight in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L507.</summary>
        public float LineWeight
        {
            get
            {
                return ((__Internal*)__Instance)->LineWeight;
            }

            set
            {
                ((__Internal*)__Instance)->LineWeight = value;
            }
        }

        /// <summary>= ImPlotMarker_None, marker specification.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L508.</summary>
        public int Marker
        {
            get
            {
                return ((__Internal*)__Instance)->Marker;
            }

            set
            {
                ((__Internal*)__Instance)->Marker = value;
            }
        }

        /// <summary>= 4,.<br/>Marker size in pixels (roughly the marker's "radius").<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L509.</summary>
        public float MarkerSize
        {
            get
            {
                return ((__Internal*)__Instance)->MarkerSize;
            }

            set
            {
                ((__Internal*)__Instance)->MarkerSize = value;
            }
        }

        /// <summary>= 1,.<br/>Outline weight of markers in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L510.</summary>
        public float MarkerWeight
        {
            get
            {
                return ((__Internal*)__Instance)->MarkerWeight;
            }

            set
            {
                ((__Internal*)__Instance)->MarkerWeight = value;
            }
        }

        /// <summary>= 1,.<br/>Alpha modifier applied to plot fills.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L511.</summary>
        public float FillAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->FillAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->FillAlpha = value;
            }
        }

        /// <summary>= 5,.<br/>Error bar whisker width in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L512.</summary>
        public float ErrorBarSize
        {
            get
            {
                return ((__Internal*)__Instance)->ErrorBarSize;
            }

            set
            {
                ((__Internal*)__Instance)->ErrorBarSize = value;
            }
        }

        /// <summary>= 1.5,.<br/>Error bar whisker weight in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L513.</summary>
        public float ErrorBarWeight
        {
            get
            {
                return ((__Internal*)__Instance)->ErrorBarWeight;
            }

            set
            {
                ((__Internal*)__Instance)->ErrorBarWeight = value;
            }
        }

        /// <summary>= 8,.<br/>Digital channels bit height (at y = 1.0f) in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L514.</summary>
        public float DigitalBitHeight
        {
            get
            {
                return ((__Internal*)__Instance)->DigitalBitHeight;
            }

            set
            {
                ((__Internal*)__Instance)->DigitalBitHeight = value;
            }
        }

        /// <summary>= 4,.<br/>Digital channels bit padding gap in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L515.</summary>
        public float DigitalBitGap
        {
            get
            {
                return ((__Internal*)__Instance)->DigitalBitGap;
            }

            set
            {
                ((__Internal*)__Instance)->DigitalBitGap = value;
            }
        }

        /// <summary>= 1,.<br/>Line thickness of border around plot area.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L517.</summary>
        public float PlotBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->PlotBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->PlotBorderSize = value;
            }
        }

        /// <summary>= 0.25.<br/>Alpha multiplier applied to minor axis grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L518.</summary>
        public float MinorAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->MinorAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->MinorAlpha = value;
            }
        }

        /// <summary>= 10,10.<br/>Major tick lengths for X and Y axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L519.</summary>
        public Vector2 MajorTickLen
        {
            get
            {
                return ((__Internal*)__Instance)->MajorTickLen
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MajorTickLen = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 5,5.<br/>Minor tick lengths for X and Y axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L520.</summary>
        public Vector2 MinorTickLen
        {
            get
            {
                return ((__Internal*)__Instance)->MinorTickLen
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MinorTickLen = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 1,1.<br/>Line thickness of major ticks.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L521.</summary>
        public Vector2 MajorTickSize
        {
            get
            {
                return ((__Internal*)__Instance)->MajorTickSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MajorTickSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 1,1.<br/>Line thickness of minor ticks.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L522.</summary>
        public Vector2 MinorTickSize
        {
            get
            {
                return ((__Internal*)__Instance)->MinorTickSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MinorTickSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 1,1.<br/>Line thickness of major grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L523.</summary>
        public Vector2 MajorGridSize
        {
            get
            {
                return ((__Internal*)__Instance)->MajorGridSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MajorGridSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 1,1.<br/>Line thickness of minor grid lines.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L524.</summary>
        public Vector2 MinorGridSize
        {
            get
            {
                return ((__Internal*)__Instance)->MinorGridSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MinorGridSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 10,10.<br/>Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L525.</summary>
        public Vector2 PlotPadding
        {
            get
            {
                return ((__Internal*)__Instance)->PlotPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->PlotPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 5,5.<br/>Padding between axes labels, tick labels, and plot edge.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L526.</summary>
        public Vector2 LabelPadding
        {
            get
            {
                return ((__Internal*)__Instance)->LabelPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->LabelPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 10,10.<br/>Legend padding from plot edges.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L527.</summary>
        public Vector2 LegendPadding
        {
            get
            {
                return ((__Internal*)__Instance)->LegendPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->LegendPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 5,5.<br/>Legend inner padding from legend edges.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L528.</summary>
        public Vector2 LegendInnerPadding
        {
            get
            {
                return ((__Internal*)__Instance)->LegendInnerPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->LegendInnerPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 5,0.<br/>Spacing between legend entries.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L529.</summary>
        public Vector2 LegendSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->LegendSpacing
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->LegendSpacing = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 10,10.<br/>Padding between plot edge and interior mouse location text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L530.</summary>
        public Vector2 MousePosPadding
        {
            get
            {
                return ((__Internal*)__Instance)->MousePosPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->MousePosPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 2,2.<br/>Text padding around annotation labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L531.</summary>
        public Vector2 AnnotationPadding
        {
            get
            {
                return ((__Internal*)__Instance)->AnnotationPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->AnnotationPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 0,0.<br/>Additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L532.</summary>
        public Vector2 FitPadding
        {
            get
            {
                return ((__Internal*)__Instance)->FitPadding
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->FitPadding = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 400,300 default size used when ImVec2(0,0) is passed to BeginPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L533.</summary>
        public Vector2 PlotDefaultSize
        {
            get
            {
                return ((__Internal*)__Instance)->PlotDefaultSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->PlotDefaultSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>= 200,150 minimum size plot frame can be when shrunk.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L534.</summary>
        public Vector2 PlotMinSize
        {
            get
            {
                return ((__Internal*)__Instance)->PlotMinSize
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: False, ReturnVarName: True */
                ;
            }

            set
            {
                ((__Internal*)__Instance)->PlotMinSize = value
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 2 */
                /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: False, ReturnVarName: True */
                ;
            }
        }

        /// <summary>The current colormap. Set this to either an ImPlotColormap_ enum or an index returned by AddColormap.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L538.</summary>
        public ImPlotColormap Colormap
        {
            get
            {
                return ((__Internal*)__Instance)->Colormap;
            }

            set
            {
                ((__Internal*)__Instance)->Colormap = value;
            }
        }

        /// <summary>= false,.<br/>Axis labels will be formatted for your timezone when ImPlotAxisFlag_Time is enabled.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L540.</summary>
        public bool UseLocalTime
        {
            get
            {
                return ((__Internal*)__Instance)->UseLocalTime != 0;
            }

            set
            {
                ((__Internal*)__Instance)->UseLocalTime = (byte)(value ? 1 : 0);
            }
        }

        /// <summary>= false,.<br/>Dates will be formatted according to ISO 8601 where applicable (e.g. YYYY-MM-DD, YYYY-MM, --MM-DD, etc.).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L541.</summary>
        public bool UseISO8601
        {
            get
            {
                return ((__Internal*)__Instance)->UseISO8601 != 0;
            }

            set
            {
                ((__Internal*)__Instance)->UseISO8601 = (byte)(value ? 1 : 0);
            }
        }

        /// <summary>= false,.<br/>Times will be formatted using a 24 hour clock.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L542.</summary>
        public bool Use24HourClock
        {
            get
            {
                return ((__Internal*)__Instance)->Use24HourClock != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Use24HourClock = (byte)(value ? 1 : 0);
            }
        }
    }

    /// <summary>Input mapping structure. Default values listed. See also MapInputDefault, MapInputReverse.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L556.</summary>
    // DEBUG: struct ImPlotInputMap {
    // DEBUG:     ImGuiMouseButton Pan;           // LMB    enables panning when held,
    // DEBUG:     ImGuiModFlags    PanMod;        // none   optional modifier that must be held for panning/fitting
    // DEBUG:     ImGuiMouseButton Fit;           // LMB    initiates fit when double clicked
    // DEBUG:     ImGuiMouseButton Select;        // RMB    begins box selection when pressed and confirms selection when released
    // DEBUG:     ImGuiMouseButton SelectCancel;  // LMB    cancels active box selection when pressed; cannot be same as Select
    // DEBUG:     ImGuiModFlags    SelectMod;     // none   optional modifier that must be held for box selection
    // DEBUG:     ImGuiModFlags    SelectHorzMod; // Alt    expands active box selection horizontally to plot edge when held
    // DEBUG:     ImGuiModFlags    SelectVertMod; // Shift  expands active box selection vertically to plot edge when held
    // DEBUG:     ImGuiMouseButton Menu;          // RMB    opens context menus (if enabled) when clicked
    // DEBUG:     ImGuiModFlags    OverrideMod;   // Ctrl   when held, all input is ignored; used to enable axis/plots as DND sources
    // DEBUG:     ImGuiModFlags    ZoomMod;       // none   optional modifier that must be held for scroll wheel zooming
    // DEBUG:     float            ZoomRate;      // 0.1f   zoom rate for scroll (e.g. 0.1f = 10% plot range every scroll click); make negative to invert
    // DEBUG:     IMPLOT_API ImPlotInputMap();
    // DEBUG: }
    public unsafe partial struct ImPlotInputMap
    {
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Internal
        {
            internal ImGuiMouseButton Pan;
            internal int PanMod;
            internal ImGuiMouseButton Fit;
            internal ImGuiMouseButton Select;
            internal ImGuiMouseButton SelectCancel;
            internal int SelectMod;
            internal int SelectHorzMod;
            internal int SelectVertMod;
            internal ImGuiMouseButton Menu;
            internal int OverrideMod;
            internal int ZoomMod;
            internal float ZoomRate;
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotInputMap@@QAE@XZ", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotInputMap@@QAE@$$QAU0@@Z", CallingConvention = CallingConvention.ThisCall)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotInputMap@@QEAA@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??0ImPlotInputMap@@QEAA@$$QEAU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr ctor(IntPtr __instance, IntPtr _0);

        }

        private ImPlotInputMap.__Internal __instance;
        internal ImPlotInputMap.__Internal __Instance => __instance;
        internal static ImPlotInputMap __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new ImPlotInputMap(native.ToPointer(), skipVTables);
        }

        internal static ImPlotInputMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPlotInputMap(native, skipVTables);
        }

        private ImPlotInputMap(__Internal native, bool skipVTables = false) : this()
        {
            __instance = native;
        }

        private ImPlotInputMap(void* native, bool skipVTables = false) : this()
        {
            __instance = *(ImPlotInputMap.__Internal*)native;
        }

        /// <summary>Input mapping structure. Default values listed. See also MapInputDefault, MapInputReverse.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L556.</summary>
        // DEBUG: ImPlotInputMap
        public ImPlotInputMap(ImPlotInputMap _0) : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ctor(new IntPtr(__instancePtr), __arg0);
                }
                else
                {
                    __Internal32.ctor(new IntPtr(__instancePtr), __arg0);
                }
            }
        }

        /// <summary>LMB.<br/>Enables panning when held,.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L557.</summary>
        public ImGuiMouseButton Pan
        {
            get
            {
                return __instance.Pan;
            }

            set
            {
                __instance.Pan = value;
            }
        }

        /// <summary>None.<br/>Optional modifier that must be held for panning/fitting.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L558.</summary>
        public int PanMod
        {
            get
            {
                return __instance.PanMod;
            }

            set
            {
                __instance.PanMod = value;
            }
        }

        /// <summary>LMB.<br/>Initiates fit when double clicked.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L559.</summary>
        public ImGuiMouseButton Fit
        {
            get
            {
                return __instance.Fit;
            }

            set
            {
                __instance.Fit = value;
            }
        }

        /// <summary>RMB.<br/>Begins box selection when pressed and confirms selection when released.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L560.</summary>
        public ImGuiMouseButton Select
        {
            get
            {
                return __instance.Select;
            }

            set
            {
                __instance.Select = value;
            }
        }

        /// <summary>LMB.<br/>Cancels active box selection when pressed; cannot be same as Select.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L561.</summary>
        public ImGuiMouseButton SelectCancel
        {
            get
            {
                return __instance.SelectCancel;
            }

            set
            {
                __instance.SelectCancel = value;
            }
        }

        /// <summary>None.<br/>Optional modifier that must be held for box selection.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L562.</summary>
        public int SelectMod
        {
            get
            {
                return __instance.SelectMod;
            }

            set
            {
                __instance.SelectMod = value;
            }
        }

        /// <summary>Alt.<br/>Expands active box selection horizontally to plot edge when held.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L563.</summary>
        public int SelectHorzMod
        {
            get
            {
                return __instance.SelectHorzMod;
            }

            set
            {
                __instance.SelectHorzMod = value;
            }
        }

        /// <summary>Shift.<br/>Expands active box selection vertically to plot edge when held.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L564.</summary>
        public int SelectVertMod
        {
            get
            {
                return __instance.SelectVertMod;
            }

            set
            {
                __instance.SelectVertMod = value;
            }
        }

        /// <summary>RMB.<br/>Opens context menus (if enabled) when clicked.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L565.</summary>
        public ImGuiMouseButton Menu
        {
            get
            {
                return __instance.Menu;
            }

            set
            {
                __instance.Menu = value;
            }
        }

        /// <summary>Ctrl.<br/>When held, all input is ignored; used to enable axis/plots as DND sources.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L566.</summary>
        public int OverrideMod
        {
            get
            {
                return __instance.OverrideMod;
            }

            set
            {
                __instance.OverrideMod = value;
            }
        }

        /// <summary>None.<br/>Optional modifier that must be held for scroll wheel zooming.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L567.</summary>
        public int ZoomMod
        {
            get
            {
                return __instance.ZoomMod;
            }

            set
            {
                __instance.ZoomMod = value;
            }
        }

        /// <summary>0.1f.<br/>Zoom rate for scroll (e.g. 0.1f = 10% plot range every scroll click); make negative to invert.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L568.</summary>
        public float ZoomRate
        {
            get
            {
                return __instance.ZoomRate;
            }

            set
            {
                __instance.ZoomRate = value;
            }
        }
    }

    public unsafe partial class ImPlot
    {
        internal partial struct __Internal
        {
        }

        private partial struct __Internal32
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@C@ImPlot@@YAXPBDPBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@E@ImPlot@@YAXPBDPBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@F@ImPlot@@YAXPBDPBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@G@ImPlot@@YAXPBDPBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@H@ImPlot@@YAXPBDPBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@I@ImPlot@@YAXPBDPBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_J@ImPlot@@YAXPBDPB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_K@ImPlot@@YAXPBDPB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@M@ImPlot@@YAXPBDPBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@N@ImPlot@@YAXPBDPBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@C@ImPlot@@YAXPBDPBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@E@ImPlot@@YAXPBDPBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@F@ImPlot@@YAXPBDPBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@G@ImPlot@@YAXPBDPBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@H@ImPlot@@YAXPBDPBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@I@ImPlot@@YAXPBDPBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_J@ImPlot@@YAXPBDPB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_K@ImPlot@@YAXPBDPB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@M@ImPlot@@YAXPBDPBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@N@ImPlot@@YAXPBDPBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@C@ImPlot@@YAXPBDPBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@E@ImPlot@@YAXPBDPBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@F@ImPlot@@YAXPBDPBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@G@ImPlot@@YAXPBDPBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@H@ImPlot@@YAXPBDPBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@I@ImPlot@@YAXPBDPBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_J@ImPlot@@YAXPBDPB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_K@ImPlot@@YAXPBDPB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@M@ImPlot@@YAXPBDPBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@N@ImPlot@@YAXPBDPBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@C@ImPlot@@YAXPBDPBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@E@ImPlot@@YAXPBDPBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@F@ImPlot@@YAXPBDPBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@G@ImPlot@@YAXPBDPBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@H@ImPlot@@YAXPBDPBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@I@ImPlot@@YAXPBDPBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_J@ImPlot@@YAXPBDPB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_K@ImPlot@@YAXPBDPB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@M@ImPlot@@YAXPBDPBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@N@ImPlot@@YAXPBDPBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@C@ImPlot@@YAXPBDPBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@E@ImPlot@@YAXPBDPBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@F@ImPlot@@YAXPBDPBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@G@ImPlot@@YAXPBDPBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@H@ImPlot@@YAXPBDPBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@I@ImPlot@@YAXPBDPBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_J@ImPlot@@YAXPBDPB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_K@ImPlot@@YAXPBDPB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@M@ImPlot@@YAXPBDPBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@N@ImPlot@@YAXPBDPBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@C@ImPlot@@YAXPBDPBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@E@ImPlot@@YAXPBDPBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@F@ImPlot@@YAXPBDPBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@G@ImPlot@@YAXPBDPBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@H@ImPlot@@YAXPBDPBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@I@ImPlot@@YAXPBDPBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_J@ImPlot@@YAXPBDPB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_K@ImPlot@@YAXPBDPB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@M@ImPlot@@YAXPBDPBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@N@ImPlot@@YAXPBDPBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPBDPBCHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPBDPBEHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPBDPBFHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPBDPBGHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPBDPBHHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPBDPBIHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPBDPB_JHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPBDPB_KHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPBDPBMHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPBDPBNHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPBDPBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPBDPBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPBDPBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPBDPBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPBDPBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPBDPBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPBDPB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPBDPB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPBDPBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPBDPBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPBDPBC11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_10([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys1, sbyte* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPBDPBE11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_11([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys1, byte* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPBDPBF11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_12([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys1, short* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPBDPBG11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_13([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys1, ushort* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPBDPBH11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_14([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys1, int* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPBDPBI11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_15([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys1, uint* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPBDPB_J11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_16([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys1, long* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPBDPB_K11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_17([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys1, ulong* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPBDPBM11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_18([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys1, float* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPBDPBN11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_19([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys1, double* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@C@ImPlot@@YAXPBDPBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@E@ImPlot@@YAXPBDPBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@F@ImPlot@@YAXPBDPBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@G@ImPlot@@YAXPBDPBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@H@ImPlot@@YAXPBDPBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@I@ImPlot@@YAXPBDPBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_J@ImPlot@@YAXPBDPB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_K@ImPlot@@YAXPBDPB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@M@ImPlot@@YAXPBDPBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@N@ImPlot@@YAXPBDPBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@C@ImPlot@@YAXPBDPBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_10([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@E@ImPlot@@YAXPBDPBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_11([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@F@ImPlot@@YAXPBDPBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_12([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@G@ImPlot@@YAXPBDPBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_13([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@H@ImPlot@@YAXPBDPBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_14([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@I@ImPlot@@YAXPBDPBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_15([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_J@ImPlot@@YAXPBDPB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_16([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_K@ImPlot@@YAXPBDPB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_17([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@M@ImPlot@@YAXPBDPBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_18([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@N@ImPlot@@YAXPBDPBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_19([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@C@ImPlot@@YAXQBQBDPBCHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, sbyte* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@E@ImPlot@@YAXQBQBDPBEHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_1([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, byte* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@F@ImPlot@@YAXQBQBDPBFHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_2([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, short* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@G@ImPlot@@YAXQBQBDPBGHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_3([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ushort* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@H@ImPlot@@YAXQBQBDPBHHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_4([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, int* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@I@ImPlot@@YAXQBQBDPBIHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_5([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, uint* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@_J@ImPlot@@YAXQBQBDPB_JHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_6([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, long* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@_K@ImPlot@@YAXQBQBDPB_KHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_7([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ulong* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@M@ImPlot@@YAXQBQBDPBMHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_8([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, float* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@N@ImPlot@@YAXQBQBDPBNHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_9([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, double* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@C@ImPlot@@YAXPBDPBC11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, sbyte* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@E@ImPlot@@YAXPBDPBE11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, byte* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@F@ImPlot@@YAXPBDPBF11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, short* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@G@ImPlot@@YAXPBDPBG11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, ushort* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@H@ImPlot@@YAXPBDPBH11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@I@ImPlot@@YAXPBDPBI11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, uint* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_J@ImPlot@@YAXPBDPB_J11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, long* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_K@ImPlot@@YAXPBDPB_K11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, ulong* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@M@ImPlot@@YAXPBDPBM11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, float* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@N@ImPlot@@YAXPBDPBN11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, double* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@C@ImPlot@@YAXPBDPBC111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, sbyte* neg, sbyte* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@E@ImPlot@@YAXPBDPBE111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, byte* neg, byte* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@F@ImPlot@@YAXPBDPBF111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, short* neg, short* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@G@ImPlot@@YAXPBDPBG111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, ushort* neg, ushort* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@H@ImPlot@@YAXPBDPBH111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int* neg, int* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@I@ImPlot@@YAXPBDPBI111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, uint* neg, uint* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_J@ImPlot@@YAXPBDPB_J111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, long* neg, long* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_K@ImPlot@@YAXPBDPB_K111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, ulong* neg, ulong* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@M@ImPlot@@YAXPBDPBM111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, float* neg, float* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@N@ImPlot@@YAXPBDPBN111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, double* neg, double* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@C@ImPlot@@YAXPBDPBCHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@E@ImPlot@@YAXPBDPBEHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@F@ImPlot@@YAXPBDPBFHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@G@ImPlot@@YAXPBDPBGHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@H@ImPlot@@YAXPBDPBHHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@I@ImPlot@@YAXPBDPBIHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_J@ImPlot@@YAXPBDPB_JHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_K@ImPlot@@YAXPBDPB_KHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@M@ImPlot@@YAXPBDPBMHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@N@ImPlot@@YAXPBDPBNHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@C@ImPlot@@YAXPBDPBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@E@ImPlot@@YAXPBDPBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@F@ImPlot@@YAXPBDPBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@G@ImPlot@@YAXPBDPBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@H@ImPlot@@YAXPBDPBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@I@ImPlot@@YAXPBDPBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_J@ImPlot@@YAXPBDPB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_K@ImPlot@@YAXPBDPB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@M@ImPlot@@YAXPBDPBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@N@ImPlot@@YAXPBDPBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@C@ImPlot@@YAXPBDPBCHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@E@ImPlot@@YAXPBDPBEHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@F@ImPlot@@YAXPBDPBFHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@G@ImPlot@@YAXPBDPBGHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@H@ImPlot@@YAXPBDPBHHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@I@ImPlot@@YAXPBDPBIHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@_J@ImPlot@@YAXPBDPB_JHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@_K@ImPlot@@YAXPBDPB_KHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@M@ImPlot@@YAXPBDPBMHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@N@ImPlot@@YAXPBDPBNHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@C@ImPlot@@YAXQBQBDPBCHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, sbyte* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@E@ImPlot@@YAXQBQBDPBEHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_1([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, byte* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@F@ImPlot@@YAXQBQBDPBFHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_2([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, short* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@G@ImPlot@@YAXQBQBDPBGHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_3([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ushort* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@H@ImPlot@@YAXQBQBDPBHHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_4([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, int* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@I@ImPlot@@YAXQBQBDPBIHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_5([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, uint* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@_J@ImPlot@@YAXQBQBDPB_JHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_6([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, long* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@_K@ImPlot@@YAXQBQBDPB_KHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_7([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ulong* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@M@ImPlot@@YAXQBQBDPBMHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_8([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, float* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@N@ImPlot@@YAXQBQBDPBNHNNNPBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_9([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, double* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@C@ImPlot@@YAXPBDPBCHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@E@ImPlot@@YAXPBDPBEHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@F@ImPlot@@YAXPBDPBFHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@G@ImPlot@@YAXPBDPBGHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@H@ImPlot@@YAXPBDPBHHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@I@ImPlot@@YAXPBDPBIHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@_J@ImPlot@@YAXPBDPB_JHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@_K@ImPlot@@YAXPBDPB_KHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@M@ImPlot@@YAXPBDPBMHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@N@ImPlot@@YAXPBDPBNHHNN0ABUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@C@ImPlot@@YANPBDPBCHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@E@ImPlot@@YANPBDPBEHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@F@ImPlot@@YANPBDPBFHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@G@ImPlot@@YANPBDPBGHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@H@ImPlot@@YANPBDPBHHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@I@ImPlot@@YANPBDPBIHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@_J@ImPlot@@YANPBDPB_JHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@_K@ImPlot@@YANPBDPB_KHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@M@ImPlot@@YANPBDPBMHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@N@ImPlot@@YANPBDPBNHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, int bins, double bar_scale, ImPlotRange.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@C@ImPlot@@YANPBDPBC1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@E@ImPlot@@YANPBDPBE1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@F@ImPlot@@YANPBDPBF1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@G@ImPlot@@YANPBDPBG1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@H@ImPlot@@YANPBDPBH1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@I@ImPlot@@YANPBDPBI1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@_J@ImPlot@@YANPBDPB_J1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@_K@ImPlot@@YANPBDPB_K1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@M@ImPlot@@YANPBDPBM1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@N@ImPlot@@YANPBDPBN1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, int x_bins, int y_bins, ImPlotRect.__Internal range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@C@ImPlot@@YAXPBDPBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@E@ImPlot@@YAXPBDPBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@F@ImPlot@@YAXPBDPBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@G@ImPlot@@YAXPBDPBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@H@ImPlot@@YAXPBDPBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@I@ImPlot@@YAXPBDPBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@_J@ImPlot@@YAXPBDPB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@_K@ImPlot@@YAXPBDPB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@M@ImPlot@@YAXPBDPBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@N@ImPlot@@YAXPBDPBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?CreateContext@ImPlot@@YAPAUImPlotContext@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CreateContext();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DestroyContext@ImPlot@@YAXPAUImPlotContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void DestroyContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetCurrentContext@ImPlot@@YAPAUImPlotContext@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetCurrentContext@ImPlot@@YAXPAUImPlotContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetCurrentContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetImGuiContext@ImPlot@@YAXPAUImGuiContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetImGuiContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginPlot@ImPlot@@YA_NPBDABUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPlot([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title_id, IntPtr size, ImPlotFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndPlot@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndPlot();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginSubplots@ImPlot@@YA_NPBDHHABUImVec2@@HPAM2@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginSubplots([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title_id, int rows, int cols, IntPtr size, ImPlotSubplotFlags flags, float* row_ratios, float* col_ratios);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndSubplots@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndSubplots();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxis@ImPlot@@YAXHPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxis(ImPlotAxis axis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, ImPlotAxisFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLimits@ImPlot@@YAXHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLinks@ImPlot@@YAXHPAN0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLinks(ImPlotAxis axis, double* link_min, double* link_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisFormat@ImPlot@@YAXHPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisFormat(ImPlotAxis axis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisFormat@ImPlot@@YAXHP6AHNPADHPAX@Z1@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisFormat(ImPlotAxis axis, IntPtr formatter, IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisTicks@ImPlot@@YAXHPBNHQBQBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisTicks(ImPlotAxis axis, double* values, int n_ticks, [MarshalAs(UnmanagedType.LPArray)] string[] labels, bool keep_default);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisTicks@ImPlot@@YAXHNNHQBQBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisTicks(ImPlotAxis axis, double v_min, double v_max, int n_ticks, [MarshalAs(UnmanagedType.LPArray)] string[] labels, bool keep_default);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisScale@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisScale(ImPlotAxis axis, ImPlotScale scale);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisScale@ImPlot@@YAXHP6ANNPAX@Z10@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisScale(ImPlotAxis axis, IntPtr forward, IntPtr inverse, IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLimitsConstraints@ImPlot@@YAXHNN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLimitsConstraints(ImPlotAxis axis, double v_min, double v_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisZoomConstraints@ImPlot@@YAXHNN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisZoomConstraints(ImPlotAxis axis, double z_min, double z_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxes@ImPlot@@YAXPBD0HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string x_label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxesLimits@ImPlot@@YAXNNNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupLegend@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupMouseText@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupFinish@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupFinish();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisLimits@ImPlot@@YAXHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisLinks@ImPlot@@YAXHPAN0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisLinks(ImPlotAxis axis, double* link_min, double* link_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisToFit@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisToFit(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxesLimits@ImPlot@@YAXNNNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxesToFit@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxesToFit();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotLineG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLineG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotLineFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotScatterG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatterG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotScatterFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotStairsG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairsG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotStairsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotShadedG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z121HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShadedG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count, ImPlotShadedFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotBarsG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z1HNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarsG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotDigitalG@ImPlot@@YAXPBDP6A?AUImPlotPoint@@HPAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigitalG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotDigitalFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotImage@ImPlot@@YAXPBDPAXABUImPlotPoint@@2ABUImVec2@@3ABUImVec4@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotImage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr user_texture_id, IntPtr bounds_min, IntPtr bounds_max, IntPtr uv0, IntPtr uv1, IntPtr tint_col, ImPlotImageFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotText@ImPlot@@YAXPBDNNABUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, double x, double y, IntPtr pix_offset, ImPlotTextFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotDummy@ImPlot@@YAXPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDummy([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImPlotDummyFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragPoint@ImPlot@@YA_NHPAN0ABUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragPoint(int id, double* x, double* y, IntPtr col, float size, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragLineX@ImPlot@@YA_NHPANABUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragLineX(int id, double* x, IntPtr col, float thickness, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragLineY@ImPlot@@YA_NHPANABUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragLineY(int id, double* y, IntPtr col, float thickness, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragRect@ImPlot@@YA_NHPAN000ABUImVec4@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragRect(int id, double* x1, double* y1, double* x2, double* y2, IntPtr col, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Annotation@ImPlot@@YAXNNABUImVec4@@ABUImVec2@@_N2@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Annotation(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Annotation@ImPlot@@YAXNNABUImVec4@@ABUImVec2@@_NPBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Annotation_1(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AnnotationV@ImPlot@@YAXNNABUImVec4@@ABUImVec2@@_NPBDPAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void AnnotationV(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagX@ImPlot@@YAXNABUImVec4@@_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagX(double x, IntPtr col, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagX@ImPlot@@YAXNABUImVec4@@PBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagX_1(double x, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagXV@ImPlot@@YAXNABUImVec4@@PBDPAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagXV(double x, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagY@ImPlot@@YAXNABUImVec4@@_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagY(double y, IntPtr col, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagY@ImPlot@@YAXNABUImVec4@@PBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagY_1(double y, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagYV@ImPlot@@YAXNABUImVec4@@PBDPAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagYV(double y, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetAxis@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetAxis(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetAxes@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetAxes(ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PixelsToPlot@ImPlot@@YA?AUImPlotPoint@@ABUImVec2@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PixelsToPlot(IntPtr @return, IntPtr pix, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PixelsToPlot@ImPlot@@YA?AUImPlotPoint@@MMHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PixelsToPlot(IntPtr @return, float x, float y, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotToPixels@ImPlot@@YA?AUImVec2@@ABUImPlotPoint@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotToPixels(IntPtr @return, IntPtr plt, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotToPixels@ImPlot@@YA?AUImVec2@@NNHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotToPixels(IntPtr @return, double x, double y, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotPos@ImPlot@@YA?AUImVec2@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotPos(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotSize@ImPlot@@YA?AUImVec2@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotSize(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotMousePos@ImPlot@@YA?AUImPlotPoint@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotMousePos(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotLimits@ImPlot@@YA?AUImPlotRect@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotLimits(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsPlotHovered@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlotHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsAxisHovered@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAxisHovered(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsSubplotsHovered@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSubplotsHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsPlotSelected@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlotSelected();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotSelection@ImPlot@@YA?AUImPlotRect@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotSelection(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?CancelPlotSelection@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CancelPlotSelection();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?HideNextItem@ImPlot@@YAX_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void HideNextItem(bool hidden, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginAlignedPlots@ImPlot@@YA_NPBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginAlignedPlots([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string group_id, bool vertical);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndAlignedPlots@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndAlignedPlots();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginLegendPopup@ImPlot@@YA_NPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginLegendPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImGuiMouseButton mouse_button);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndLegendPopup@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndLegendPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsLegendEntryHovered@ImPlot@@YA_NPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsLegendEntryHovered([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetPlot@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetPlot();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetAxis@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetAxis(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetLegend@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetLegend();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndDragDropTarget@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourcePlot@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourceAxis@ImPlot@@YA_NHH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourceAxis(ImPlotAxis axis, ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourceItem@ImPlot@@YA_NPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourceItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndDragDropSource@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetStyle@ImPlot@@YAAAUImPlotStyle@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsAuto@ImPlot@@YAXPAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsAuto(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsClassic@ImPlot@@YAXPAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsClassic(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsDark@ImPlot@@YAXPAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsDark(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsLight@ImPlot@@YAXPAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsLight(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleColor@ImPlot@@YAXHI@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleColor(ImPlotCol idx, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleColor@ImPlot@@YAXHABUImVec4@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleColor(ImPlotCol idx, IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopStyleColor@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar(ImPlotStyleVar idx, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar_1(ImPlotStyleVar idx, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHABUImVec2@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar(ImPlotStyleVar idx, IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopStyleVar@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextLineStyle@ImPlot@@YAXABUImVec4@@M@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextLineStyle(IntPtr col, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextFillStyle@ImPlot@@YAXABUImVec4@@M@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextFillStyle(IntPtr col, float alpha_mod);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextMarkerStyle@ImPlot@@YAXHMABUImVec4@@M0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextMarkerStyle(ImPlotMarker marker, float size, IntPtr fill, float weight, IntPtr outline);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextErrorBarStyle@ImPlot@@YAXABUImVec4@@MM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextErrorBarStyle(IntPtr col, float size, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetLastItemColor@ImPlot@@YA?AUImVec4@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetLastItemColor(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetStyleColorName@ImPlot@@YAPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetStyleColorName(ImPlotCol idx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetMarkerName@ImPlot@@YAPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetMarkerName(ImPlotMarker idx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AddColormap@ImPlot@@YAHPBDPBUImVec4@@H_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap AddColormap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, IntPtr cols, int size, bool qual);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AddColormap@ImPlot@@YAHPBDPBIH_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap AddColormap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint* cols, int size, bool qual);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapCount@ImPlot@@YAHXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int GetColormapCount();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapName@ImPlot@@YAPBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetColormapName(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapIndex@ImPlot@@YAHPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap GetColormapIndex([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushColormap@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushColormap(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushColormap@ImPlot@@YAXPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushColormap_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopColormap@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopColormap(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?NextColormapColor@ImPlot@@YA?AUImVec4@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void NextColormapColor(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapSize@ImPlot@@YAHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int GetColormapSize(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapColor@ImPlot@@YA?AUImVec4@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetColormapColor(IntPtr @return, int idx, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SampleColormap@ImPlot@@YA?AUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SampleColormap(IntPtr @return, float t, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapScale@ImPlot@@YAXPBDNNABUImVec2@@0HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ColormapScale([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double scale_min, double scale_max, IntPtr size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapSlider@ImPlot@@YA_NPBDPAMPAUImVec4@@0H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColormapSlider([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* t, IntPtr @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapButton@ImPlot@@YA_NPBDABUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColormapButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, IntPtr size, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BustColorCache@ImPlot@@YAXPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void BustColorCache([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string plot_title_id);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetInputMap@ImPlot@@YAAAUImPlotInputMap@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetInputMap();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?MapInputDefault@ImPlot@@YAXPAUImPlotInputMap@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void MapInputDefault(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?MapInputReverse@ImPlot@@YAXPAUImPlotInputMap@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void MapInputReverse(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ItemIcon@ImPlot@@YAXABUImVec4@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ItemIcon(IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ItemIcon@ImPlot@@YAXI@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ItemIcon(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapIcon@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ColormapIcon(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotDrawList@ImPlot@@YAPAUImDrawList@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetPlotDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushPlotClipRect@ImPlot@@YAXM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushPlotClipRect(float expand);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopPlotClipRect@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopPlotClipRect();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowStyleSelector@ImPlot@@YA_NPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowColormapSelector@ImPlot@@YA_NPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowColormapSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowInputMapSelector@ImPlot@@YA_NPBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowInputMapSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowStyleEditor@ImPlot@@YAXPAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowStyleEditor(IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowUserGuide@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowMetricsWindow@ImPlot@@YAXPA_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowMetricsWindow(bool* p_popen);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowDemoWindow@ImPlot@@YAXPA_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowDemoWindow(bool* p_open);

        }

        private partial struct __Internal64
        {
            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@C@ImPlot@@YAXPEBDPEBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@E@ImPlot@@YAXPEBDPEBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@F@ImPlot@@YAXPEBDPEBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@G@ImPlot@@YAXPEBDPEBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@H@ImPlot@@YAXPEBDPEBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@I@ImPlot@@YAXPEBDPEBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_J@ImPlot@@YAXPEBDPEB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_K@ImPlot@@YAXPEBDPEB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@M@ImPlot@@YAXPEBDPEBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@N@ImPlot@@YAXPEBDPEBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@C@ImPlot@@YAXPEBDPEBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@E@ImPlot@@YAXPEBDPEBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@F@ImPlot@@YAXPEBDPEBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@G@ImPlot@@YAXPEBDPEBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@H@ImPlot@@YAXPEBDPEBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@I@ImPlot@@YAXPEBDPEBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_J@ImPlot@@YAXPEBDPEB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@_K@ImPlot@@YAXPEBDPEB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@M@ImPlot@@YAXPEBDPEBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotLine@N@ImPlot@@YAXPEBDPEBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLine_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotLineFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@C@ImPlot@@YAXPEBDPEBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@E@ImPlot@@YAXPEBDPEBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@F@ImPlot@@YAXPEBDPEBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@G@ImPlot@@YAXPEBDPEBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@H@ImPlot@@YAXPEBDPEBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@I@ImPlot@@YAXPEBDPEBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_J@ImPlot@@YAXPEBDPEB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_K@ImPlot@@YAXPEBDPEB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@M@ImPlot@@YAXPEBDPEBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@N@ImPlot@@YAXPEBDPEBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@C@ImPlot@@YAXPEBDPEBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@E@ImPlot@@YAXPEBDPEBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@F@ImPlot@@YAXPEBDPEBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@G@ImPlot@@YAXPEBDPEBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@H@ImPlot@@YAXPEBDPEBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@I@ImPlot@@YAXPEBDPEBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_J@ImPlot@@YAXPEBDPEB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@_K@ImPlot@@YAXPEBDPEB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@M@ImPlot@@YAXPEBDPEBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotScatter@N@ImPlot@@YAXPEBDPEBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatter_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotScatterFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@C@ImPlot@@YAXPEBDPEBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@E@ImPlot@@YAXPEBDPEBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@F@ImPlot@@YAXPEBDPEBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@G@ImPlot@@YAXPEBDPEBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@H@ImPlot@@YAXPEBDPEBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@I@ImPlot@@YAXPEBDPEBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_J@ImPlot@@YAXPEBDPEB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_K@ImPlot@@YAXPEBDPEB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@M@ImPlot@@YAXPEBDPEBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@N@ImPlot@@YAXPEBDPEBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@C@ImPlot@@YAXPEBDPEBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@E@ImPlot@@YAXPEBDPEBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@F@ImPlot@@YAXPEBDPEBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@G@ImPlot@@YAXPEBDPEBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@H@ImPlot@@YAXPEBDPEBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@I@ImPlot@@YAXPEBDPEBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_J@ImPlot@@YAXPEBDPEB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@_K@ImPlot@@YAXPEBDPEB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@M@ImPlot@@YAXPEBDPEBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStairs@N@ImPlot@@YAXPEBDPEBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairs_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotStairsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPEBDPEBCHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPEBDPEBEHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPEBDPEBFHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPEBDPEBGHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPEBDPEBHHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPEBDPEBIHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPEBDPEB_JHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPEBDPEB_KHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPEBDPEBMHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPEBDPEBNHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPEBDPEBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPEBDPEBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPEBDPEBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPEBDPEBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPEBDPEBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPEBDPEBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPEBDPEB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPEBDPEB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPEBDPEBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPEBDPEBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@C@ImPlot@@YAXPEBDPEBC11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_10([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys1, sbyte* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@E@ImPlot@@YAXPEBDPEBE11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_11([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys1, byte* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@F@ImPlot@@YAXPEBDPEBF11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_12([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys1, short* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@G@ImPlot@@YAXPEBDPEBG11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_13([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys1, ushort* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@H@ImPlot@@YAXPEBDPEBH11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_14([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys1, int* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@I@ImPlot@@YAXPEBDPEBI11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_15([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys1, uint* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_J@ImPlot@@YAXPEBDPEB_J11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_16([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys1, long* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@_K@ImPlot@@YAXPEBDPEB_K11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_17([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys1, ulong* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@M@ImPlot@@YAXPEBDPEBM11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_18([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys1, float* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotShaded@N@ImPlot@@YAXPEBDPEBN11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShaded_19([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys1, double* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@C@ImPlot@@YAXPEBDPEBCHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@E@ImPlot@@YAXPEBDPEBEHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@F@ImPlot@@YAXPEBDPEBFHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@G@ImPlot@@YAXPEBDPEBGHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@H@ImPlot@@YAXPEBDPEBHHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@I@ImPlot@@YAXPEBDPEBIHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_J@ImPlot@@YAXPEBDPEB_JHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_K@ImPlot@@YAXPEBDPEB_KHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@M@ImPlot@@YAXPEBDPEBMHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@N@ImPlot@@YAXPEBDPEBNHNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@C@ImPlot@@YAXPEBDPEBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_10([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@E@ImPlot@@YAXPEBDPEBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_11([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@F@ImPlot@@YAXPEBDPEBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_12([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@G@ImPlot@@YAXPEBDPEBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_13([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@H@ImPlot@@YAXPEBDPEBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_14([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@I@ImPlot@@YAXPEBDPEBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_15([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_J@ImPlot@@YAXPEBDPEB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_16([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@_K@ImPlot@@YAXPEBDPEB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_17([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@M@ImPlot@@YAXPEBDPEBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_18([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBars@N@ImPlot@@YAXPEBDPEBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBars_19([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@C@ImPlot@@YAXQEBQEBDPEBCHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, sbyte* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@E@ImPlot@@YAXQEBQEBDPEBEHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_1([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, byte* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@F@ImPlot@@YAXQEBQEBDPEBFHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_2([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, short* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@G@ImPlot@@YAXQEBQEBDPEBGHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_3([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ushort* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@H@ImPlot@@YAXQEBQEBDPEBHHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_4([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, int* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@I@ImPlot@@YAXQEBQEBDPEBIHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_5([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, uint* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@_J@ImPlot@@YAXQEBQEBDPEB_JHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_6([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, long* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@_K@ImPlot@@YAXQEBQEBDPEB_KHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_7([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ulong* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@M@ImPlot@@YAXQEBQEBDPEBMHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_8([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, float* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotBarGroups@N@ImPlot@@YAXQEBQEBDPEBNHHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarGroups_9([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, double* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@C@ImPlot@@YAXPEBDPEBC11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, sbyte* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@E@ImPlot@@YAXPEBDPEBE11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, byte* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@F@ImPlot@@YAXPEBDPEBF11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, short* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@G@ImPlot@@YAXPEBDPEBG11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, ushort* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@H@ImPlot@@YAXPEBDPEBH11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@I@ImPlot@@YAXPEBDPEBI11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, uint* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_J@ImPlot@@YAXPEBDPEB_J11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, long* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_K@ImPlot@@YAXPEBDPEB_K11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, ulong* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@M@ImPlot@@YAXPEBDPEBM11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, float* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@N@ImPlot@@YAXPEBDPEBN11HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, double* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@C@ImPlot@@YAXPEBDPEBC111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, sbyte* neg, sbyte* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@E@ImPlot@@YAXPEBDPEBE111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, byte* neg, byte* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@F@ImPlot@@YAXPEBDPEBF111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, short* neg, short* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@G@ImPlot@@YAXPEBDPEBG111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, ushort* neg, ushort* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@H@ImPlot@@YAXPEBDPEBH111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int* neg, int* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@I@ImPlot@@YAXPEBDPEBI111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, uint* neg, uint* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_J@ImPlot@@YAXPEBDPEB_J111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, long* neg, long* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@_K@ImPlot@@YAXPEBDPEB_K111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, ulong* neg, ulong* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@M@ImPlot@@YAXPEBDPEBM111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, float* neg, float* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotErrorBars@N@ImPlot@@YAXPEBDPEBN111HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotErrorBars_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, double* neg, double* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@C@ImPlot@@YAXPEBDPEBCHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@E@ImPlot@@YAXPEBDPEBEHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@F@ImPlot@@YAXPEBDPEBFHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@G@ImPlot@@YAXPEBDPEBGHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@H@ImPlot@@YAXPEBDPEBHHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@I@ImPlot@@YAXPEBDPEBIHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_J@ImPlot@@YAXPEBDPEB_JHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_K@ImPlot@@YAXPEBDPEB_KHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@M@ImPlot@@YAXPEBDPEBMHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@N@ImPlot@@YAXPEBDPEBNHNNNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@C@ImPlot@@YAXPEBDPEBC1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@E@ImPlot@@YAXPEBDPEBE1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@F@ImPlot@@YAXPEBDPEBF1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@G@ImPlot@@YAXPEBDPEBG1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@H@ImPlot@@YAXPEBDPEBH1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@I@ImPlot@@YAXPEBDPEBI1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_J@ImPlot@@YAXPEBDPEB_J1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@_K@ImPlot@@YAXPEBDPEB_K1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@M@ImPlot@@YAXPEBDPEBM1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotStems@N@ImPlot@@YAXPEBDPEBN1HNHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStems_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@C@ImPlot@@YAXPEBDPEBCHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@E@ImPlot@@YAXPEBDPEBEHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@F@ImPlot@@YAXPEBDPEBFHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@G@ImPlot@@YAXPEBDPEBGHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@H@ImPlot@@YAXPEBDPEBHHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@I@ImPlot@@YAXPEBDPEBIHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@_J@ImPlot@@YAXPEBDPEB_JHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@_K@ImPlot@@YAXPEBDPEB_KHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@M@ImPlot@@YAXPEBDPEBMHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotInfLines@N@ImPlot@@YAXPEBDPEBNHHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotInfLines_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, ImPlotInfLinesFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@C@ImPlot@@YAXQEBQEBDPEBCHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, sbyte* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@E@ImPlot@@YAXQEBQEBDPEBEHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_1([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, byte* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@F@ImPlot@@YAXQEBQEBDPEBFHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_2([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, short* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@G@ImPlot@@YAXQEBQEBDPEBGHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_3([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ushort* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@H@ImPlot@@YAXQEBQEBDPEBHHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_4([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, int* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@I@ImPlot@@YAXQEBQEBDPEBIHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_5([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, uint* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@_J@ImPlot@@YAXQEBQEBDPEB_JHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_6([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, long* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@_K@ImPlot@@YAXQEBQEBDPEB_KHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_7([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, ulong* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@M@ImPlot@@YAXQEBQEBDPEBMHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_8([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, float* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotPieChart@N@ImPlot@@YAXQEBQEBDPEBNHNNNPEBDNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotPieChart_9([MarshalAs(UnmanagedType.LPArray)] string[] label_ids, double* values, int count, double x, double y, double radius, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, double angle0, ImPlotPieChartFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@C@ImPlot@@YAXPEBDPEBCHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@E@ImPlot@@YAXPEBDPEBEHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@F@ImPlot@@YAXPEBDPEBFHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@G@ImPlot@@YAXPEBDPEBGHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@H@ImPlot@@YAXPEBDPEBHHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@I@ImPlot@@YAXPEBDPEBIHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@_J@ImPlot@@YAXPEBDPEB_JHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@_K@ImPlot@@YAXPEBDPEB_KHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@M@ImPlot@@YAXPEBDPEBMHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHeatmap@N@ImPlot@@YAXPEBDPEBNHHNN0AEBUImPlotPoint@@2H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotHeatmap_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int rows, int cols, double scale_min, double scale_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_fmt, IntPtr bounds_min, IntPtr bounds_max, ImPlotHeatmapFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@C@ImPlot@@YANPEBDPEBCHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@E@ImPlot@@YANPEBDPEBEHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@F@ImPlot@@YANPEBDPEBFHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@G@ImPlot@@YANPEBDPEBGHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@H@ImPlot@@YANPEBDPEBHHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@I@ImPlot@@YANPEBDPEBIHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@_J@ImPlot@@YANPEBDPEB_JHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@_K@ImPlot@@YANPEBDPEB_KHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@M@ImPlot@@YANPEBDPEBMHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram@N@ImPlot@@YANPEBDPEBNHHNUImPlotRange@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* values, int count, int bins, double bar_scale, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@C@ImPlot@@YANPEBDPEBC1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@E@ImPlot@@YANPEBDPEBE1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@F@ImPlot@@YANPEBDPEBF1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@G@ImPlot@@YANPEBDPEBG1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@H@ImPlot@@YANPEBDPEBH1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@I@ImPlot@@YANPEBDPEBI1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@_J@ImPlot@@YANPEBDPEB_J1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@_K@ImPlot@@YANPEBDPEB_K1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@M@ImPlot@@YANPEBDPEBM1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotHistogram2D@N@ImPlot@@YANPEBDPEBN1HHHUImPlotRect@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern double PlotHistogram2D_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, int x_bins, int y_bins, IntPtr range, ImPlotHistogramFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@C@ImPlot@@YAXPEBDPEBC1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, sbyte* xs, sbyte* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@E@ImPlot@@YAXPEBDPEBE1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, byte* xs, byte* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@F@ImPlot@@YAXPEBDPEBF1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, short* xs, short* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@G@ImPlot@@YAXPEBDPEBG1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ushort* xs, ushort* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@H@ImPlot@@YAXPEBDPEBH1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, int* xs, int* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@I@ImPlot@@YAXPEBDPEBI1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_5([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, uint* xs, uint* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@_J@ImPlot@@YAXPEBDPEB_J1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_6([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, long* xs, long* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@_K@ImPlot@@YAXPEBDPEB_K1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_7([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ulong* xs, ulong* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@M@ImPlot@@YAXPEBDPEBM1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, float* xs, float* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "??$PlotDigital@N@ImPlot@@YAXPEBDPEBN1HHHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigital_9([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, double* xs, double* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?CreateContext@ImPlot@@YAPEAUImPlotContext@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CreateContext();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DestroyContext@ImPlot@@YAXPEAUImPlotContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void DestroyContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetCurrentContext@ImPlot@@YAPEAUImPlotContext@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetCurrentContext@ImPlot@@YAXPEAUImPlotContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetCurrentContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetImGuiContext@ImPlot@@YAXPEAUImGuiContext@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetImGuiContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginPlot@ImPlot@@YA_NPEBDAEBUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPlot([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title_id, IntPtr size, ImPlotFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndPlot@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndPlot();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginSubplots@ImPlot@@YA_NPEBDHHAEBUImVec2@@HPEAM2@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginSubplots([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title_id, int rows, int cols, IntPtr size, ImPlotSubplotFlags flags, float* row_ratios, float* col_ratios);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndSubplots@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndSubplots();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxis@ImPlot@@YAXHPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxis(ImPlotAxis axis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, ImPlotAxisFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLimits@ImPlot@@YAXHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLinks@ImPlot@@YAXHPEAN0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLinks(ImPlotAxis axis, double* link_min, double* link_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisFormat@ImPlot@@YAXHPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisFormat(ImPlotAxis axis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisFormat@ImPlot@@YAXHP6AHNPEADHPEAX@Z1@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisFormat(ImPlotAxis axis, IntPtr formatter, IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisTicks@ImPlot@@YAXHPEBNHQEBQEBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisTicks(ImPlotAxis axis, double* values, int n_ticks, [MarshalAs(UnmanagedType.LPArray)] string[] labels, bool keep_default);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisTicks@ImPlot@@YAXHNNHQEBQEBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisTicks(ImPlotAxis axis, double v_min, double v_max, int n_ticks, [MarshalAs(UnmanagedType.LPArray)] string[] labels, bool keep_default);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisScale@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisScale(ImPlotAxis axis, ImPlotScale scale);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisScale@ImPlot@@YAXHP6ANNPEAX@Z10@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisScale(ImPlotAxis axis, IntPtr forward, IntPtr inverse, IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisLimitsConstraints@ImPlot@@YAXHNN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisLimitsConstraints(ImPlotAxis axis, double v_min, double v_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxisZoomConstraints@ImPlot@@YAXHNN@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxisZoomConstraints(ImPlotAxis axis, double z_min, double z_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxes@ImPlot@@YAXPEBD0HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string x_label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupAxesLimits@ImPlot@@YAXNNNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupLegend@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupMouseText@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetupFinish@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetupFinish();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisLimits@ImPlot@@YAXHNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisLinks@ImPlot@@YAXHPEAN0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisLinks(ImPlotAxis axis, double* link_min, double* link_max);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxisToFit@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxisToFit(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxesLimits@ImPlot@@YAXNNNNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextAxesToFit@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextAxesToFit();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotLineG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotLineG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotLineFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotScatterG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotScatterG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotScatterFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotStairsG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotStairsG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotStairsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotShadedG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z121HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotShadedG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count, ImPlotShadedFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotBarsG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z1HNH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotBarsG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotDigitalG@ImPlot@@YAXPEBDP6A?AUImPlotPoint@@HPEAX@Z1HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDigitalG([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr getter, IntPtr data, int count, ImPlotDigitalFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotImage@ImPlot@@YAXPEBDPEAXAEBUImPlotPoint@@2AEBUImVec2@@3AEBUImVec4@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotImage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, IntPtr user_texture_id, IntPtr bounds_min, IntPtr bounds_max, IntPtr uv0, IntPtr uv1, IntPtr tint_col, ImPlotImageFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotText@ImPlot@@YAXPEBDNNAEBUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, double x, double y, IntPtr pix_offset, ImPlotTextFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotDummy@ImPlot@@YAXPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotDummy([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImPlotDummyFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragPoint@ImPlot@@YA_NHPEAN0AEBUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragPoint(int id, double* x, double* y, IntPtr col, float size, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragLineX@ImPlot@@YA_NHPEANAEBUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragLineX(int id, double* x, IntPtr col, float thickness, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragLineY@ImPlot@@YA_NHPEANAEBUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragLineY(int id, double* y, IntPtr col, float thickness, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?DragRect@ImPlot@@YA_NHPEAN000AEBUImVec4@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragRect(int id, double* x1, double* y1, double* x2, double* y2, IntPtr col, ImPlotDragToolFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Annotation@ImPlot@@YAXNNAEBUImVec4@@AEBUImVec2@@_N2@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Annotation(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?Annotation@ImPlot@@YAXNNAEBUImVec4@@AEBUImVec2@@_NPEBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void Annotation_1(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AnnotationV@ImPlot@@YAXNNAEBUImVec4@@AEBUImVec2@@_NPEBDPEAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void AnnotationV(double x, double y, IntPtr col, IntPtr pix_offset, bool clamp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagX@ImPlot@@YAXNAEBUImVec4@@_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagX(double x, IntPtr col, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagX@ImPlot@@YAXNAEBUImVec4@@PEBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagX_1(double x, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagXV@ImPlot@@YAXNAEBUImVec4@@PEBDPEAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagXV(double x, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagY@ImPlot@@YAXNAEBUImVec4@@_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagY(double y, IntPtr col, bool round);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagY@ImPlot@@YAXNAEBUImVec4@@PEBDZZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagY_1(double y, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?TagYV@ImPlot@@YAXNAEBUImVec4@@PEBDPEAD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void TagYV(double y, IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt, Object args);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetAxis@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetAxis(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetAxes@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetAxes(ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PixelsToPlot@ImPlot@@YA?AUImPlotPoint@@AEBUImVec2@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PixelsToPlot(IntPtr @return, IntPtr pix, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PixelsToPlot@ImPlot@@YA?AUImPlotPoint@@MMHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PixelsToPlot(IntPtr @return, float x, float y, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotToPixels@ImPlot@@YA?AUImVec2@@AEBUImPlotPoint@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotToPixels(IntPtr @return, IntPtr plt, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PlotToPixels@ImPlot@@YA?AUImVec2@@NNHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PlotToPixels(IntPtr @return, double x, double y, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotPos@ImPlot@@YA?AUImVec2@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotPos(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotSize@ImPlot@@YA?AUImVec2@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotSize(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotMousePos@ImPlot@@YA?AUImPlotPoint@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotMousePos(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotLimits@ImPlot@@YA?AUImPlotRect@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotLimits(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsPlotHovered@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlotHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsAxisHovered@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAxisHovered(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsSubplotsHovered@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSubplotsHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsPlotSelected@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlotSelected();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotSelection@ImPlot@@YA?AUImPlotRect@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetPlotSelection(IntPtr @return, ImPlotAxis x_axis, ImPlotAxis y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?CancelPlotSelection@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CancelPlotSelection();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?HideNextItem@ImPlot@@YAX_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void HideNextItem(bool hidden, ImPlotCond cond);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginAlignedPlots@ImPlot@@YA_NPEBD_N@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginAlignedPlots([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string group_id, bool vertical);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndAlignedPlots@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndAlignedPlots();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginLegendPopup@ImPlot@@YA_NPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginLegendPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImGuiMouseButton mouse_button);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndLegendPopup@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndLegendPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?IsLegendEntryHovered@ImPlot@@YA_NPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsLegendEntryHovered([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetPlot@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetPlot();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetAxis@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetAxis(ImPlotAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropTargetLegend@ImPlot@@YA_NXZ", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetLegend();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndDragDropTarget@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourcePlot@ImPlot@@YA_NH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourceAxis@ImPlot@@YA_NHH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourceAxis(ImPlotAxis axis, ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BeginDragDropSourceItem@ImPlot@@YA_NPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSourceItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_id, ImGuiDragDropFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?EndDragDropSource@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetStyle@ImPlot@@YAAEAUImPlotStyle@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsAuto@ImPlot@@YAXPEAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsAuto(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsClassic@ImPlot@@YAXPEAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsClassic(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsDark@ImPlot@@YAXPEAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsDark(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?StyleColorsLight@ImPlot@@YAXPEAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void StyleColorsLight(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleColor@ImPlot@@YAXHI@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleColor(ImPlotCol idx, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleColor@ImPlot@@YAXHAEBUImVec4@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleColor(ImPlotCol idx, IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopStyleColor@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar(ImPlotStyleVar idx, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar_1(ImPlotStyleVar idx, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushStyleVar@ImPlot@@YAXHAEBUImVec2@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushStyleVar(ImPlotStyleVar idx, IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopStyleVar@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextLineStyle@ImPlot@@YAXAEBUImVec4@@M@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextLineStyle(IntPtr col, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextFillStyle@ImPlot@@YAXAEBUImVec4@@M@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextFillStyle(IntPtr col, float alpha_mod);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextMarkerStyle@ImPlot@@YAXHMAEBUImVec4@@M0@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextMarkerStyle(ImPlotMarker marker, float size, IntPtr fill, float weight, IntPtr outline);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SetNextErrorBarStyle@ImPlot@@YAXAEBUImVec4@@MM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SetNextErrorBarStyle(IntPtr col, float size, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetLastItemColor@ImPlot@@YA?AUImVec4@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetLastItemColor(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetStyleColorName@ImPlot@@YAPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetStyleColorName(ImPlotCol idx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetMarkerName@ImPlot@@YAPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetMarkerName(ImPlotMarker idx);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AddColormap@ImPlot@@YAHPEBDPEBUImVec4@@H_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap AddColormap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, IntPtr cols, int size, bool qual);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?AddColormap@ImPlot@@YAHPEBDPEBIH_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap AddColormap([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint* cols, int size, bool qual);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapCount@ImPlot@@YAHXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int GetColormapCount();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapName@ImPlot@@YAPEBDH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetColormapName(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapIndex@ImPlot@@YAHPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern ImPlotColormap GetColormapIndex([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushColormap@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushColormap(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushColormap@ImPlot@@YAXPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushColormap_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopColormap@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopColormap(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?NextColormapColor@ImPlot@@YA?AUImVec4@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void NextColormapColor(IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapSize@ImPlot@@YAHH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int GetColormapSize(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetColormapColor@ImPlot@@YA?AUImVec4@@HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void GetColormapColor(IntPtr @return, int idx, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?SampleColormap@ImPlot@@YA?AUImVec4@@MH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void SampleColormap(IntPtr @return, float t, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapScale@ImPlot@@YAXPEBDNNAEBUImVec2@@0HH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ColormapScale([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double scale_min, double scale_max, IntPtr size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapSlider@ImPlot@@YA_NPEBDPEAMPEAUImVec4@@0H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColormapSlider([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* t, IntPtr @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapButton@ImPlot@@YA_NPEBDAEBUImVec2@@H@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColormapButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, IntPtr size, ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?BustColorCache@ImPlot@@YAXPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void BustColorCache([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string plot_title_id);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetInputMap@ImPlot@@YAAEAUImPlotInputMap@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetInputMap();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?MapInputDefault@ImPlot@@YAXPEAUImPlotInputMap@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void MapInputDefault(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?MapInputReverse@ImPlot@@YAXPEAUImPlotInputMap@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void MapInputReverse(IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ItemIcon@ImPlot@@YAXAEBUImVec4@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ItemIcon(IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ItemIcon@ImPlot@@YAXI@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ItemIcon(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ColormapIcon@ImPlot@@YAXH@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ColormapIcon(ImPlotColormap cmap);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?GetPlotDrawList@ImPlot@@YAPEAUImDrawList@@XZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr GetPlotDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PushPlotClipRect@ImPlot@@YAXM@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PushPlotClipRect(float expand);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?PopPlotClipRect@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void PopPlotClipRect();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowStyleSelector@ImPlot@@YA_NPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowColormapSelector@ImPlot@@YA_NPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowColormapSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowInputMapSelector@ImPlot@@YA_NPEBD@Z", CallingConvention = CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowInputMapSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowStyleEditor@ImPlot@@YAXPEAUImPlotStyle@@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowStyleEditor(IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowUserGuide@ImPlot@@YAXXZ", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowMetricsWindow@ImPlot@@YAXPEA_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowMetricsWindow(bool* p_popen);

            [SuppressUnmanagedCodeSecurity, DllImport("implot", EntryPoint = "?ShowDemoWindow@ImPlot@@YAXPEA_N@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void ShowDemoWindow(bool* p_open);

        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS8>(const char* label_id, const ImS8* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, sbyte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotLine(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotLine(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU8>(const char* label_id, const ImU8* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, byte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotLine_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotLine_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS16>(const char* label_id, const ImS16* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref short values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU16>(const char* label_id, const ImU16* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS32>(const char* label_id, const ImS32* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref int values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU32>(const char* label_id, const ImU32* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref uint values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS64>(const char* label_id, const ImS64* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref long values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU64>(const char* label_id, const ImU64* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<float>(const char* label_id, const float* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref float values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L848.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<double>(const char* label_id, const double* values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref double values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotLine_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotLine_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, sbyte* xs, sbyte* ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotLine(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotLine(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, byte* xs, byte* ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotLine_1(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotLine_1(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<float>(const char* label_id, const float* xs, const float* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D line plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L849.</summary>
        // DEBUG: template <> IMPLOT_API void PlotLine<double>(const char* label_id, const double* xs, const double* ys, int count, ImPlotLineFlags flags, int offset, int stride)
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotLine_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotLine_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS8>(const char* label_id, const ImS8* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, sbyte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotScatter(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotScatter(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU8>(const char* label_id, const ImU8* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, byte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotScatter_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotScatter_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS16>(const char* label_id, const ImS16* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref short values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU16>(const char* label_id, const ImU16* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS32>(const char* label_id, const ImS32* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref int values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU32>(const char* label_id, const ImU32* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS64>(const char* label_id, const ImS64* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref long values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU64>(const char* label_id, const ImU64* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<float>(const char* label_id, const float* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref float values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L853.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<double>(const char* label_id, const double* values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref double values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotScatter_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotScatter_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, sbyte* xs, sbyte* ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotScatter(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotScatter(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, byte* xs, byte* ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotScatter_1(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotScatter_1(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<float>(const char* label_id, const float* xs, const float* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L854.</summary>
        // DEBUG: template <> IMPLOT_API void PlotScatter<double>(const char* label_id, const double* xs, const double* ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotScatter_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotScatter_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS8>(const char* label_id, const ImS8* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, sbyte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStairs(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStairs(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU8>(const char* label_id, const ImU8* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, byte* values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStairs_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStairs_1(label_id, values, count, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS16>(const char* label_id, const ImS16* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref short values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_2(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU16>(const char* label_id, const ImU16* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_3(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS32>(const char* label_id, const ImS32* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref int values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_4(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU32>(const char* label_id, const ImU32* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_5(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS64>(const char* label_id, const ImS64* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref long values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_6(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU64>(const char* label_id, const ImU64* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_7(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<float>(const char* label_id, const float* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref float values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_8(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L858.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<double>(const char* label_id, const double* values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref double values, int count, double xscale = (double)(1), double xstart = (double)(0), ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStairs_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStairs_9(label_id, __arg1, count, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, sbyte* xs, sbyte* ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStairs(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStairs(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, byte* xs, byte* ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStairs_1(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStairs_1(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<float>(const char* label_id, const float* xs, const float* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L859.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStairs<double>(const char* label_id, const double* xs, const double* ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStairs_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStairs_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS8>(const char* label_id, const ImS8* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, sbyte* values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded(label_id, values, count, yref, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded(label_id, values, count, yref, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU8>(const char* label_id, const ImU8* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, byte* values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded_1(label_id, values, count, yref, xscale, xstart, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded_1(label_id, values, count, yref, xscale, xstart, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS16>(const char* label_id, const ImS16* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref short values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_2(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_2(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU16>(const char* label_id, const ImU16* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_3(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_3(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS32>(const char* label_id, const ImS32* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref int values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_4(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_4(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU32>(const char* label_id, const ImU32* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref uint values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_5(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_5(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS64>(const char* label_id, const ImS64* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref long values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_6(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_6(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU64>(const char* label_id, const ImU64* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_7(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_7(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<float>(const char* label_id, const float* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref float values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_8(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_8(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L863.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<double>(const char* label_id, const double* values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref double values, int count, double yref = (double)(0), double xscale = (double)(1), double xstart = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotShaded_9(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotShaded_9(label_id, __arg1, count, yref, xscale, xstart, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, sbyte* xs, sbyte* ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded(label_id, xs, ys, count, yref, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded(label_id, xs, ys, count, yref, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, byte* xs, byte* ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded_1(label_id, xs, ys, count, yref, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded_1(label_id, xs, ys, count, yref, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_2(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_2(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_3(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_3(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_4(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_4(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_5(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_5(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_6(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_6(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_7(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_7(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<float>(const char* label_id, const float* xs, const float* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_8(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_8(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L864.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<double>(const char* label_id, const double* xs, const double* ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref = (double)(0), ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotShaded_9(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotShaded_9(label_id, __arg1, __arg2, count, yref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys1, const ImS8* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, sbyte* xs, sbyte* ys1, sbyte* ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded_10(label_id, xs, ys1, ys2, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded_10(label_id, xs, ys1, ys2, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys1, const ImU8* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, byte* xs, byte* ys1, byte* ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShaded_11(label_id, xs, ys1, ys2, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotShaded_11(label_id, xs, ys1, ys2, count, flags, offset, stride);
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys1, const ImS16* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (short* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_12(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_12(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys1, const ImU16* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (ushort* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_13(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_13(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys1, const ImS32* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (int* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_14(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_14(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys1, const ImU32* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (uint* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_15(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_15(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys1, const ImS64* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (long* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_16(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_16(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys1, const ImU64* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (ulong* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_17(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_17(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<float>(const char* label_id, const float* xs, const float* ys1, const float* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (float* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_18(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_18(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L865.</summary>
        // DEBUG: template <> IMPLOT_API void PlotShaded<double>(const char* label_id, const double* xs, const double* ys1, const double* ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys12 = &ys1)
                {
                    var __arg2 = __ys12;
                    fixed (double* __ys23 = &ys2)
                    {
                        var __arg3 = __ys23;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotShaded_19(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotShaded_19(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS8>(const char* label_id, const ImS8* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, sbyte* values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBars(label_id, values, count, bar_size, shift, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotBars(label_id, values, count, bar_size, shift, flags, offset, stride);
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU8>(const char* label_id, const ImU8* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, byte* values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBars_1(label_id, values, count, bar_size, shift, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotBars_1(label_id, values, count, bar_size, shift, flags, offset, stride);
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS16>(const char* label_id, const ImS16* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref short values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_2(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_2(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU16>(const char* label_id, const ImU16* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_3(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_3(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS32>(const char* label_id, const ImS32* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref int values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_4(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_4(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU32>(const char* label_id, const ImU32* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_5(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_5(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS64>(const char* label_id, const ImS64* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref long values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_6(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_6(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU64>(const char* label_id, const ImU64* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_7(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_7(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<float>(const char* label_id, const float* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref float values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_8(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_8(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L869.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<double>(const char* label_id, const double* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref double values, int count, double bar_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBars_9(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotBars_9(label_id, __arg1, count, bar_size, shift, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, sbyte* xs, sbyte* ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBars_10(label_id, xs, ys, count, bar_size, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotBars_10(label_id, xs, ys, count, bar_size, flags, offset, stride);
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, byte* xs, byte* ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBars_11(label_id, xs, ys, count, bar_size, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotBars_11(label_id, xs, ys, count, bar_size, flags, offset, stride);
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_12(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_12(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_13(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_13(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_14(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_14(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_15(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_15(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_16(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_16(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_17(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_17(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<float>(const char* label_id, const float* xs, const float* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_18(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_18(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L870.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBars<double>(const char* label_id, const double* xs, const double* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotBars_19(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotBars_19(label_id, __arg1, __arg2, count, bar_size, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImS8>(const char* const label_ids[], const ImS8* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, sbyte* values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBarGroups(label_ids, values, item_count, group_count, group_size, shift, flags);
            }
            else
            {
                __Internal32.PlotBarGroups(label_ids, values, item_count, group_count, group_size, shift, flags);
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImU8>(const char* const label_ids[], const ImU8* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, byte* values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBarGroups_1(label_ids, values, item_count, group_count, group_size, shift, flags);
            }
            else
            {
                __Internal32.PlotBarGroups_1(label_ids, values, item_count, group_count, group_size, shift, flags);
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImS16>(const char* const label_ids[], const ImS16* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_2(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_2(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImU16>(const char* const label_ids[], const ImU16* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_3(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_3(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImS32>(const char* const label_ids[], const ImS32* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_4(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_4(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImU32>(const char* const label_ids[], const ImU32* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_5(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_5(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImS64>(const char* const label_ids[], const ImS64* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_6(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_6(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<ImU64>(const char* const label_ids[], const ImU64* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_7(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_7(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<float>(const char* const label_ids[], const float* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_8(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_8(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L874.</summary>
        // DEBUG: template <> IMPLOT_API void PlotBarGroups<double>(const char* const label_ids[], const double* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size = 0.67000000000000004, double shift = (double)(0), ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)(0))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotBarGroups_9(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
                else
                {
                    __Internal32.PlotBarGroups_9(label_ids, __arg1, item_count, group_count, group_size, shift, flags);
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, const ImS8* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, sbyte* xs, sbyte* ys, sbyte* err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotErrorBars(label_id, xs, ys, err, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotErrorBars(label_id, xs, ys, err, count, flags, offset, stride);
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, const ImU8* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, byte* xs, byte* ys, byte* err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotErrorBars_1(label_id, xs, ys, err, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotErrorBars_1(label_id, xs, ys, err, count, flags, offset, stride);
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, const ImS16* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (short* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_2(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_2(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, const ImU16* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (ushort* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_3(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_3(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, const ImS32* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (int* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_4(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_4(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, const ImU32* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (uint* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_5(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_5(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, const ImS64* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (long* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_6(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_6(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, const ImU64* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (ulong* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_7(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_7(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<float>(const char* label_id, const float* xs, const float* ys, const float* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (float* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_8(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_8(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L877.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<double>(const char* label_id, const double* xs, const double* ys, const double* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (double* __err3 = &err)
                    {
                        var __arg3 = __err3;
                        if (Environment.Is64BitProcess)
                        {
                            __Internal64.PlotErrorBars_9(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                        else
                        {
                            __Internal32.PlotErrorBars_9(label_id, __arg1, __arg2, __arg3, count, flags, offset, stride);
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, const ImS8* neg, const ImS8* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, sbyte* xs, sbyte* ys, sbyte* neg, sbyte* pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotErrorBars(label_id, xs, ys, neg, pos, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotErrorBars(label_id, xs, ys, neg, pos, count, flags, offset, stride);
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, const ImU8* neg, const ImU8* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, byte* xs, byte* ys, byte* neg, byte* pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotErrorBars_1(label_id, xs, ys, neg, pos, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotErrorBars_1(label_id, xs, ys, neg, pos, count, flags, offset, stride);
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, const ImS16* neg, const ImS16* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (short* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (short* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_2(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_2(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, const ImU16* neg, const ImU16* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (ushort* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (ushort* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_3(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_3(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, const ImS32* neg, const ImS32* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (int* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (int* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_4(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_4(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, const ImU32* neg, const ImU32* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (uint* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (uint* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_5(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_5(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, const ImS64* neg, const ImS64* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (long* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (long* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_6(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_6(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, const ImU64* neg, const ImU64* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (ulong* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (ulong* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_7(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_7(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<float>(const char* label_id, const float* xs, const float* ys, const float* neg, const float* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (float* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (float* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_8(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_8(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L878.</summary>
        // DEBUG: template <> IMPLOT_API void PlotErrorBars<double>(const char* label_id, const double* xs, const double* ys, const double* neg, const double* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    fixed (double* __neg3 = &neg)
                    {
                        var __arg3 = __neg3;
                        fixed (double* __pos4 = &pos)
                        {
                            var __arg4 = __pos4;
                            if (Environment.Is64BitProcess)
                            {
                                __Internal64.PlotErrorBars_9(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                            else
                            {
                                __Internal32.PlotErrorBars_9(label_id, __arg1, __arg2, __arg3, __arg4, count, flags, offset, stride);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS8>(const char* label_id, const ImS8* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, sbyte* values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStems(label_id, values, count, @ref, scale, start, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStems(label_id, values, count, @ref, scale, start, flags, offset, stride);
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU8>(const char* label_id, const ImU8* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, byte* values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStems_1(label_id, values, count, @ref, scale, start, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStems_1(label_id, values, count, @ref, scale, start, flags, offset, stride);
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS16>(const char* label_id, const ImS16* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref short values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_2(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_2(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU16>(const char* label_id, const ImU16* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_3(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_3(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS32>(const char* label_id, const ImS32* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref int values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_4(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_4(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU32>(const char* label_id, const ImU32* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref uint values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_5(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_5(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS64>(const char* label_id, const ImS64* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref long values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_6(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_6(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU64>(const char* label_id, const ImU64* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_7(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_7(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<float>(const char* label_id, const float* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref float values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_8(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_8(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L881.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<double>(const char* label_id, const double* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref double values, int count, double @ref = 0, double scale = (double)(1), double start = (double)(0), ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotStems_9(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotStems_9(label_id, __arg1, count, @ref, scale, start, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, sbyte* xs, sbyte* ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStems(label_id, xs, ys, count, @ref, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStems(label_id, xs, ys, count, @ref, flags, offset, stride);
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, byte* xs, byte* ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStems_1(label_id, xs, ys, count, @ref, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotStems_1(label_id, xs, ys, count, @ref, flags, offset, stride);
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_2(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_2(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_3(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_3(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_4(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_4(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_5(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_5(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_6(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_6(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_7(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_7(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<float>(const char* label_id, const float* xs, const float* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_8(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_8(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots stems. Vertical by default.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L882.</summary>
        // DEBUG: template <> IMPLOT_API void PlotStems<double>(const char* label_id, const double* xs, const double* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride)
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref = 0, ImPlotStemsFlags flags = (ImPlotStemsFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotStems_9(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotStems_9(label_id, __arg1, __arg2, count, @ref, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImS8>(const char* label_id, const ImS8* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, sbyte* values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotInfLines(label_id, values, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotInfLines(label_id, values, count, flags, offset, stride);
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImU8>(const char* label_id, const ImU8* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, byte* values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotInfLines_1(label_id, values, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotInfLines_1(label_id, values, count, flags, offset, stride);
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImS16>(const char* label_id, const ImS16* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_2(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_2(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImU16>(const char* label_id, const ImU16* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_3(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_3(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImS32>(const char* label_id, const ImS32* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_4(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_4(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImU32>(const char* label_id, const ImU32* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_5(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_5(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImS64>(const char* label_id, const ImS64* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_6(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_6(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<ImU64>(const char* label_id, const ImU64* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_7(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_7(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<float>(const char* label_id, const float* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_8(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_8(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L885.</summary>
        // DEBUG: template <> IMPLOT_API void PlotInfLines<double>(const char* label_id, const double* values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotInfLines_9(label_id, __arg1, count, flags, offset, stride);
                }
                else
                {
                    __Internal32.PlotInfLines_9(label_id, __arg1, count, flags, offset, stride);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImS8>(const char* const label_ids[], const ImS8* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, sbyte* values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotPieChart(label_ids, values, count, x, y, radius, label_fmt, angle0, flags);
            }
            else
            {
                __Internal32.PlotPieChart(label_ids, values, count, x, y, radius, label_fmt, angle0, flags);
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImU8>(const char* const label_ids[], const ImU8* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, byte* values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotPieChart_1(label_ids, values, count, x, y, radius, label_fmt, angle0, flags);
            }
            else
            {
                __Internal32.PlotPieChart_1(label_ids, values, count, x, y, radius, label_fmt, angle0, flags);
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImS16>(const char* const label_ids[], const ImS16* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_2(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_2(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImU16>(const char* const label_ids[], const ImU16* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_3(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_3(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImS32>(const char* const label_ids[], const ImS32* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_4(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_4(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImU32>(const char* const label_ids[], const ImU32* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_5(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_5(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImS64>(const char* const label_ids[], const ImS64* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_6(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_6(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<ImU64>(const char* const label_ids[], const ImU64* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_7(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_7(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<float>(const char* const label_ids[], const float* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_8(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_8(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L888.</summary>
        // DEBUG: template <> IMPLOT_API void PlotPieChart<double>(const char* const label_ids[], const double* values, int count, double x, double y, double radius, const char* label_fmt, double angle0, ImPlotPieChartFlags flags)
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt = "%.1f", double angle0 = (double)(90), ImPlotPieChartFlags flags = (ImPlotPieChartFlags)(0))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotPieChart_9(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
                else
                {
                    __Internal32.PlotPieChart_9(label_ids, __arg1, count, x, y, radius, label_fmt, angle0, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS8>(const char* label_id, const ImS8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, sbyte* values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            var ____arg7 = bounds_min.__Instance;
            var __arg7 = new IntPtr(&____arg7);
            var ____arg8 = bounds_max.__Instance;
            var __arg8 = new IntPtr(&____arg8);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
            }
            else
            {
                __Internal32.PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU8>(const char* label_id, const ImU8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, byte* values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            var ____arg7 = bounds_min.__Instance;
            var __arg7 = new IntPtr(&____arg7);
            var ____arg8 = bounds_max.__Instance;
            var __arg8 = new IntPtr(&____arg8);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotHeatmap_1(label_id, values, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
            }
            else
            {
                __Internal32.PlotHeatmap_1(label_id, values, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS16>(const char* label_id, const ImS16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_2(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_2(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU16>(const char* label_id, const ImU16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_3(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_3(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS32>(const char* label_id, const ImS32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_4(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_4(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU32>(const char* label_id, const ImU32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_5(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_5(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS64>(const char* label_id, const ImS64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_6(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_6(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU64>(const char* label_id, const ImU64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_7(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_7(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<float>(const char* label_id, const float* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_8(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_8(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<double>(const char* label_id, const double* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)(0))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                var ____arg7 = bounds_min.__Instance;
                var __arg7 = new IntPtr(&____arg7);
                var ____arg8 = bounds_max.__Instance;
                var __arg8 = new IntPtr(&____arg8);
                if (Environment.Is64BitProcess)
                {
                    __Internal64.PlotHeatmap_9(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
                else
                {
                    __Internal32.PlotHeatmap_9(label_id, __arg1, rows, cols, scale_min, scale_max, label_fmt, __arg7, __arg8, flags);
                }
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImS8>(const char* label_id, const ImS8* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, sbyte* values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            var __arg5 = range.__Instance;
            var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram(label_id, values, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram(label_id, values, count, bins, bar_scale, __arg5, flags);
            return ___ret;
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImU8>(const char* label_id, const ImU8* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, byte* values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            var __arg5 = range.__Instance;
            var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_1(label_id, values, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_1(label_id, values, count, bins, bar_scale, __arg5, flags);
            return ___ret;
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImS16>(const char* label_id, const ImS16* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref short values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (short* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_2(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_2(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImU16>(const char* label_id, const ImU16* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (ushort* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_3(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_3(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImS32>(const char* label_id, const ImS32* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref int values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (int* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_4(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_4(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImU32>(const char* label_id, const ImU32* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (uint* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_5(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_5(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImS64>(const char* label_id, const ImS64* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref long values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (long* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_6(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_6(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<ImU64>(const char* label_id, const ImU64* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (ulong* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_7(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_7(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<float>(const char* label_id, const float* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref float values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_8(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_8(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.<br/>Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L895.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram<double>(const char* label_id, const double* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        public static double PlotHistogram(string label_id, ref double values, int count, int bins = (int)ImPlotBin.Sturges, double bar_scale = 1.0, ImPlotRange range = new ImPlotRange(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                var __arg5 = range.__Instance;
                var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram_9(label_id, __arg1, count, bins, bar_scale, new IntPtr(&__arg5), flags) : __Internal32.PlotHistogram_9(label_id, __arg1, count, bins, bar_scale, __arg5, flags);
                return ___ret;
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, sbyte* xs, sbyte* ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            var __arg6 = range.__Instance;
            var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D(label_id, xs, ys, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D(label_id, xs, ys, count, x_bins, y_bins, __arg6, flags);
            return ___ret;
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, byte* xs, byte* ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            var __arg6 = range.__Instance;
            var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_1(label_id, xs, ys, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_1(label_id, xs, ys, count, x_bins, y_bins, __arg6, flags);
            return ___ret;
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_2(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_2(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_3(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_3(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_4(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_4(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_5(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_5(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_6(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_6(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_7(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_7(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<float>(const char* label_id, const float* xs, const float* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_8(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_8(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of.<br/>#xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L899.</summary>
        // DEBUG: template <> IMPLOT_API double PlotHistogram2D<double>(const char* label_id, const double* xs, const double* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins = (int)ImPlotBin.Sturges, int y_bins = (int)ImPlotBin.Sturges, ImPlotRect range = new ImPlotRect(), ImPlotHistogramFlags flags = (ImPlotHistogramFlags)(0))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    var __arg6 = range.__Instance;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.PlotHistogram2D_9(label_id, __arg1, __arg2, count, x_bins, y_bins, new IntPtr(&__arg6), flags) : __Internal32.PlotHistogram2D_9(label_id, __arg1, __arg2, count, x_bins, y_bins, __arg6, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImS8>(const char* label_id, const ImS8* xs, const ImS8* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, sbyte* xs, sbyte* ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(sbyte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotDigital(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotDigital(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImU8>(const char* label_id, const ImU8* xs, const ImU8* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, byte* xs, byte* ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(byte))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotDigital_1(label_id, xs, ys, count, flags, offset, stride);
            }
            else
            {
                __Internal32.PlotDigital_1(label_id, xs, ys, count, flags, offset, stride);
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImS16>(const char* label_id, const ImS16* xs, const ImS16* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(short))
        {
            fixed (short* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (short* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_2(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImU16>(const char* label_id, const ImU16* xs, const ImU16* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(ushort))
        {
            fixed (ushort* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ushort* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_3(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImS32>(const char* label_id, const ImS32* xs, const ImS32* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(int))
        {
            fixed (int* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (int* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_4(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImU32>(const char* label_id, const ImU32* xs, const ImU32* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(uint))
        {
            fixed (uint* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (uint* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_5(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImS64>(const char* label_id, const ImS64* xs, const ImS64* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(long))
        {
            fixed (long* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (long* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_6(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<ImU64>(const char* label_id, const ImU64* xs, const ImU64* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(ulong))
        {
            fixed (ulong* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (ulong* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_7(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<float>(const char* label_id, const float* xs, const float* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(float))
        {
            fixed (float* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (float* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_8(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L902.</summary>
        // DEBUG: template <> IMPLOT_API void PlotDigital<double>(const char* label_id, const double* xs, const double* ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0), int offset = (int)(0), int stride = sizeof(double))
        {
            fixed (double* __xs1 = &xs)
            {
                var __arg1 = __xs1;
                fixed (double* __ys2 = &ys)
                {
                    var __arg2 = __ys2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.PlotDigital_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                    else
                    {
                        __Internal32.PlotDigital_9(label_id, __arg1, __arg2, count, flags, offset, stride);
                    }
                }
            }
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS8>(const char* label_id, const ImS8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, sbyte* values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS8>(const char* label_id, const ImS8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, sbyte* values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU8>(const char* label_id, const ImU8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, byte* values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU8>(const char* label_id, const ImU8* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, byte* values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS16>(const char* label_id, const ImS16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS16>(const char* label_id, const ImS16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU16>(const char* label_id, const ImU16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU16>(const char* label_id, const ImU16* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS32>(const char* label_id, const ImS32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS32>(const char* label_id, const ImS32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU32>(const char* label_id, const ImU32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU32>(const char* label_id, const ImU32* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS64>(const char* label_id, const ImS64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImS64>(const char* label_id, const ImS64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU64>(const char* label_id, const ImU64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<ImU64>(const char* label_id, const ImU64* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<float>(const char* label_id, const float* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<float>(const char* label_id, const float* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<double>(const char* label_id, const double* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min = (double)(0), double scale_max = (double)(0), string label_fmt = "%.1f")
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, new ImPlotPoint(0, 0), new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to NULL for no labels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L891.</summary>
        // DEBUG: template <> IMPLOT_API void PlotHeatmap<double>(const char* label_id, const double* values, int rows, int cols, double scale_min, double scale_max, const char* label_fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags)
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            PlotHeatmap(label_id, ref values, rows, cols, scale_min, scale_max, label_fmt, bounds_min, new ImPlotPoint(1, 1), 0);
        }

        /// <summary>Creates a new ImPlot context. Call this after ImGui::CreateContext.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L592.</summary>
        // DEBUG: ImPlotContext* CreateContext()
        public static ImPlotContext CreateContext()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.CreateContext() : __Internal32.CreateContext();
            var __result0 = ImPlotContext.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Destroys an ImPlot context. Call this before ImGui::DestroyContext. NULL = destroy current context.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L594.</summary>
        // DEBUG: void DestroyContext(ImPlotContext* ctx = NULL)
        public static void DestroyContext(ImPlotContext ctx = default)
        {
            var __arg0 = ctx is null ? IntPtr.Zero : ctx.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.DestroyContext(__arg0);
            }
            else
            {
                __Internal32.DestroyContext(__arg0);
            }
        }

        /// <summary>Returns the current ImPlot context. NULL if no context has ben set.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L596.</summary>
        // DEBUG: ImPlotContext* GetCurrentContext()
        public static ImPlotContext GetCurrentContext()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetCurrentContext() : __Internal32.GetCurrentContext();
            var __result0 = ImPlotContext.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Sets the current ImPlot context.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L598.</summary>
        // DEBUG: void SetCurrentContext(ImPlotContext* ctx)
        public static void SetCurrentContext(ImPlotContext ctx)
        {
            var __arg0 = ctx is null ? IntPtr.Zero : ctx.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetCurrentContext(__arg0);
            }
            else
            {
                __Internal32.SetCurrentContext(__arg0);
            }
        }

        /// <summary>Sets the current **ImGui** context. This is ONLY necessary if you are compiling.<br/>ImPlot as a DLL (not recommended) separate from your ImGui compilation. It.<br/>Sets the global variable GImGui, which is not shared across DLL boundaries.<br/>See GImGui documentation in imgui.cpp for more details.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L604.</summary>
        // DEBUG: void SetImGuiContext(ImGuiContext* ctx)
        public static void SetImGuiContext(IntPtr ctx)
        {
            var __arg0 = ctx
            /* DEBUG: TypeMapContext.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetImGuiContext(__arg0);
            }
            else
            {
                __Internal32.SetImGuiContext(__arg0);
            }
        }

        /// <summary>- #title_id must be unique to the current ImGui ID scope. If you need to avoid ID.<br/>Collisions or don't want to display a title in the plot, use double hashes.<br/>(e.g. "MyPlot##HiddenIdText" or "##NoTitle").<br/>- #size is the **frame** size of the plot widget, not the plot area. The default.<br/>Size of plots (i.e. when ImVec2(0,0)) can be modified in your ImPlotStyle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L626.</summary>
        // DEBUG: bool BeginPlot(const char* title_id, const ImVec2& size=ImVec2(-1,0), ImPlotFlags flags=0)
        public static bool BeginPlot(string title_id, Vector2 size, ImPlotFlags flags = (ImPlotFlags)(0))
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref size))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginPlot(title_id, __arg1, flags) : __Internal32.BeginPlot(title_id, __arg1, flags);
            return ___ret;
        }

        /// <summary>Only call EndPlot() if BeginPlot() returns true! Typically called at the end.<br/>Of an if statement conditioned on BeginPlot(). See example above.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L630.</summary>
        // DEBUG: void EndPlot()
        public static void EndPlot()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndPlot();
            }
            else
            {
                __Internal32.EndPlot();
            }
        }

        /// <summary>- The #title_id parameter of _BeginPlot_ (see above) does NOT have to be.<br/>Unique when called inside of a subplot context. Subplot IDs are hashed.<br/>For your convenience so you don't have call PushID or generate unique title.<br/>Strings. Simply pass an empty string to BeginPlot unless you want to title.<br/>Each subplot.<br/>- The #size parameter of _BeginPlot_ (see above) is ignored when inside of a.<br/>Subplot context. The actual size of the subplot will be based on the.<br/>#size value you pass to _BeginSubplots_ and #row/#col_ratios if provided.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L682.</summary>
        // DEBUG: bool BeginSubplots(const char* title_id,
        // DEBUG:                              int rows,
        // DEBUG:                              int cols,
        // DEBUG:                              const ImVec2& size,
        // DEBUG:                              ImPlotSubplotFlags flags = 0,
        // DEBUG:                              float* row_ratios        = NULL,
        // DEBUG:                              float* col_ratios        = NULL)
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios, ref float col_ratios)
        {
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref size))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            fixed (float* __row_ratios5 = &row_ratios)
            {
                var __arg5 = __row_ratios5;
                fixed (float* __col_ratios6 = &col_ratios)
                {
                    var __arg6 = __col_ratios6;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.BeginSubplots(title_id, rows, cols, __arg3, flags, __arg5, __arg6) : __Internal32.BeginSubplots(title_id, rows, cols, __arg3, flags, __arg5, __arg6);
                    return ___ret;
                }
            }
        }

        /// <summary>Only call EndSubplots() if BeginSubplots() returns true! Typically called at the end.<br/>Of an if statement conditioned on BeginSublots(). See example above.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L692.</summary>
        // DEBUG: void EndSubplots()
        public static void EndSubplots()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndSubplots();
            }
            else
            {
                __Internal32.EndSubplots();
            }
        }

        /// <summary>Enables an axis or sets the label and/or flags for an existing axis. Leave #label = NULL for no label.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L724.</summary>
        // DEBUG: void SetupAxis(ImAxis axis, const char* label=NULL, ImPlotAxisFlags flags=0)
        public static void SetupAxis(ImPlotAxis axis, string label = default, ImPlotAxisFlags flags = (ImPlotAxisFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxis(axis, label, flags);
            }
            else
            {
                __Internal32.SetupAxis(axis, label, flags);
            }
        }

        /// <summary>Sets an axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L726.</summary>
        // DEBUG: void SetupAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond_Once)
        public static void SetupAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond.Once)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisLimits(axis, v_min, v_max, cond);
            }
            else
            {
                __Internal32.SetupAxisLimits(axis, v_min, v_max, cond);
            }
        }

        /// <summary>Links an axis range limits to external values. Set to NULL for no linkage. The pointer data must remain valid until EndPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L728.</summary>
        // DEBUG: void SetupAxisLinks(ImAxis axis, double* link_min, double* link_max)
        public static void SetupAxisLinks(ImPlotAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* __link_min1 = &link_min)
            {
                var __arg1 = __link_min1;
                fixed (double* __link_max2 = &link_max)
                {
                    var __arg2 = __link_max2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.SetupAxisLinks(axis, __arg1, __arg2);
                    }
                    else
                    {
                        __Internal32.SetupAxisLinks(axis, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>Sets the format of numeric axis labels via formater specifier (default="%g"). Formated values will be double (i.e. use %f).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L730.</summary>
        // DEBUG: void SetupAxisFormat(ImAxis axis, const char* fmt)
        public static void SetupAxisFormat(ImPlotAxis axis, string fmt)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisFormat(axis, fmt);
            }
            else
            {
                __Internal32.SetupAxisFormat(axis, fmt);
            }
        }

        /// <summary>Sets the format of numeric axis labels via formatter callback. Given #value, write a label into #buff. Optionally pass user data.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L732.</summary>
        // DEBUG: void SetupAxisFormat(ImAxis axis, ImPlotFormatter formatter, void* data=NULL)
        public static void SetupAxisFormat(ImPlotAxis axis, ImPlotFormatter formatter, IntPtr data = default)
        {
            var __arg1 = formatter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(formatter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisFormat(axis, __arg1, data);
            }
            else
            {
                __Internal32.SetupAxisFormat(axis, __arg1, data);
            }
        }

        /// <summary>Sets an axis' ticks and optionally the labels. To keep the default ticks, set #keep_default=true.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L734.</summary>
        // DEBUG: void SetupAxisTicks(ImAxis axis, const double* values, int n_ticks, const char* const labels[]=NULL, bool keep_default=false)
        public static void SetupAxisTicks(ImPlotAxis axis, ref double values, int n_ticks, string[] labels = null, bool keep_default = false)
        {
            fixed (double* __values1 = &values)
            {
                var __arg1 = __values1;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.SetupAxisTicks(axis, __arg1, n_ticks, labels, keep_default);
                }
                else
                {
                    __Internal32.SetupAxisTicks(axis, __arg1, n_ticks, labels, keep_default);
                }
            }
        }

        /// <summary>Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L736.</summary>
        // DEBUG: void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, const char* const labels[]=NULL, bool keep_default=false)
        public static void SetupAxisTicks(ImPlotAxis axis, double v_min, double v_max, int n_ticks, string[] labels = null, bool keep_default = false)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisTicks(axis, v_min, v_max, n_ticks, labels, keep_default);
            }
            else
            {
                __Internal32.SetupAxisTicks(axis, v_min, v_max, n_ticks, labels, keep_default);
            }
        }

        /// <summary>Sets an axis' scale using built-in options.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L738.</summary>
        // DEBUG: void SetupAxisScale(ImAxis axis, ImPlotScale scale)
        public static void SetupAxisScale(ImPlotAxis axis, ImPlotScale scale)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisScale(axis, scale);
            }
            else
            {
                __Internal32.SetupAxisScale(axis, scale);
            }
        }

        /// <summary>Sets an axis' scale using user supplied forward and inverse transfroms.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L740.</summary>
        // DEBUG: void SetupAxisScale(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse, void* data=NULL)
        public static void SetupAxisScale(ImPlotAxis axis, ImPlotTransform forward, ImPlotTransform inverse, IntPtr data = default)
        {
            var __arg1 = forward == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(forward);
            var __arg2 = inverse == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(inverse);
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisScale(axis, __arg1, __arg2, data);
            }
            else
            {
                __Internal32.SetupAxisScale(axis, __arg1, __arg2, data);
            }
        }

        /// <summary>Sets an axis' limits constraints.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L742.</summary>
        // DEBUG: void SetupAxisLimitsConstraints(ImAxis axis, double v_min, double v_max)
        public static void SetupAxisLimitsConstraints(ImPlotAxis axis, double v_min, double v_max)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisLimitsConstraints(axis, v_min, v_max);
            }
            else
            {
                __Internal32.SetupAxisLimitsConstraints(axis, v_min, v_max);
            }
        }

        /// <summary>Sets an axis' zoom constraints.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L744.</summary>
        // DEBUG: void SetupAxisZoomConstraints(ImAxis axis, double z_min, double z_max)
        public static void SetupAxisZoomConstraints(ImPlotAxis axis, double z_min, double z_max)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxisZoomConstraints(axis, z_min, z_max);
            }
            else
            {
                __Internal32.SetupAxisZoomConstraints(axis, z_min, z_max);
            }
        }

        /// <summary>Sets the label and/or flags for primary X and Y axes (shorthand for two calls to SetupAxis).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L747.</summary>
        // DEBUG: void SetupAxes(const char* x_label, const char* y_label, ImPlotAxisFlags x_flags=0, ImPlotAxisFlags y_flags=0)
        public static void SetupAxes(string x_label, string y_label, ImPlotAxisFlags x_flags = (ImPlotAxisFlags)(0), ImPlotAxisFlags y_flags = (ImPlotAxisFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxes(x_label, y_label, x_flags, y_flags);
            }
            else
            {
                __Internal32.SetupAxes(x_label, y_label, x_flags, y_flags);
            }
        }

        /// <summary>Sets the primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L749.</summary>
        // DEBUG: void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond_Once)
        public static void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond.Once)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
            }
            else
            {
                __Internal32.SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
            }
        }

        /// <summary>Sets up the plot legend.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L752.</summary>
        // DEBUG: void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags=0)
        public static void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags = (ImPlotLegendFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupLegend(location, flags);
            }
            else
            {
                __Internal32.SetupLegend(location, flags);
            }
        }

        /// <summary>Set the location of the current plot's mouse position text (default = South|East).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L754.</summary>
        // DEBUG: void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags=0)
        public static void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags = (ImPlotMouseTextFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupMouseText(location, flags);
            }
            else
            {
                __Internal32.SetupMouseText(location, flags);
            }
        }

        /// <summary>Explicitly finalize plot setup. Once you call this, you cannot make anymore Setup calls for the current plot!<br/>Note that calling this function is OPTIONAL; it will be called by the first subsequent setup-locking API call.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L758.</summary>
        // DEBUG: void SetupFinish()
        public static void SetupFinish()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetupFinish();
            }
            else
            {
                __Internal32.SetupFinish();
            }
        }

        /// <summary>Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L784.</summary>
        // DEBUG: void SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond_Once)
        public static void SetNextAxisLimits(ImPlotAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond.Once)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextAxisLimits(axis, v_min, v_max, cond);
            }
            else
            {
                __Internal32.SetNextAxisLimits(axis, v_min, v_max, cond);
            }
        }

        /// <summary>Links an upcoming axis range limits to external values. Set to NULL for no linkage. The pointer data must remain valid until EndPlot!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L786.</summary>
        // DEBUG: void SetNextAxisLinks(ImAxis axis, double* link_min, double* link_max)
        public static void SetNextAxisLinks(ImPlotAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* __link_min1 = &link_min)
            {
                var __arg1 = __link_min1;
                fixed (double* __link_max2 = &link_max)
                {
                    var __arg2 = __link_max2;
                    if (Environment.Is64BitProcess)
                    {
                        __Internal64.SetNextAxisLinks(axis, __arg1, __arg2);
                    }
                    else
                    {
                        __Internal32.SetNextAxisLinks(axis, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>Set an upcoming axis to auto fit to its data.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L788.</summary>
        // DEBUG: void SetNextAxisToFit(ImAxis axis)
        public static void SetNextAxisToFit(ImPlotAxis axis)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextAxisToFit(axis);
            }
            else
            {
                __Internal32.SetNextAxisToFit(axis);
            }
        }

        /// <summary>Sets the upcoming primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L791.</summary>
        // DEBUG: void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond_Once)
        public static void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond.Once)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
            }
            else
            {
                __Internal32.SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
            }
        }

        /// <summary>Sets all upcoming axes to auto fit to their data.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L793.</summary>
        // DEBUG: void SetNextAxesToFit()
        public static void SetNextAxesToFit()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextAxesToFit();
            }
            else
            {
                __Internal32.SetNextAxesToFit();
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L850.</summary>
        // DEBUG: void PlotLineG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotLineFlags flags=0)
        public static void PlotLineG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotLineFlags flags = (ImPlotLineFlags)(0))
        {
            var __arg1 = getter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotLineG(label_id, __arg1, data, count, flags);
            }
            else
            {
                __Internal32.PlotLineG(label_id, __arg1, data, count, flags);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L855.</summary>
        // DEBUG: void PlotScatterG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotScatterFlags flags=0)
        public static void PlotScatterG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotScatterFlags flags = (ImPlotScatterFlags)(0))
        {
            var __arg1 = getter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotScatterG(label_id, __arg1, data, count, flags);
            }
            else
            {
                __Internal32.PlotScatterG(label_id, __arg1, data, count, flags);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L860.</summary>
        // DEBUG: void PlotStairsG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotStairsFlags flags=0)
        public static void PlotStairsG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotStairsFlags flags = (ImPlotStairsFlags)(0))
        {
            var __arg1 = getter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotStairsG(label_id, __arg1, data, count, flags);
            }
            else
            {
                __Internal32.PlotStairsG(label_id, __arg1, data, count, flags);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L866.</summary>
        // DEBUG: void PlotShadedG(const char* label_id, ImPlotGetter getter1, void* data1, ImPlotGetter getter2, void* data2, int count, ImPlotShadedFlags flags=0)
        public static void PlotShadedG(string label_id, ImPlotGetter getter1, IntPtr data1, ImPlotGetter getter2, IntPtr data2, int count, ImPlotShadedFlags flags = (ImPlotShadedFlags)(0))
        {
            var __arg1 = getter1 == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter1);
            var __arg3 = getter2 == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter2);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotShadedG(label_id, __arg1, data1, __arg3, data2, count, flags);
            }
            else
            {
                __Internal32.PlotShadedG(label_id, __arg1, data1, __arg3, data2, count, flags);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L871.</summary>
        // DEBUG: void PlotBarsG(const char* label_id, ImPlotGetter getter, void* data, int count, double bar_size, ImPlotBarsFlags flags=0)
        public static void PlotBarsG(string label_id, ImPlotGetter getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags = (ImPlotBarsFlags)(0))
        {
            var __arg1 = getter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotBarsG(label_id, __arg1, data, count, bar_size, flags);
            }
            else
            {
                __Internal32.PlotBarsG(label_id, __arg1, data, count, bar_size, flags);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L903.</summary>
        // DEBUG: void PlotDigitalG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotDigitalFlags flags=0)
        public static void PlotDigitalG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotDigitalFlags flags = (ImPlotDigitalFlags)(0))
        {
            var __arg1 = getter == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(getter);
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotDigitalG(label_id, __arg1, data, count, flags);
            }
            else
            {
                __Internal32.PlotDigitalG(label_id, __arg1, data, count, flags);
            }
        }

        /// <summary>Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L906.</summary>
        // DEBUG: void PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, const ImVec2& uv0=ImVec2(0,0), const ImVec2& uv1=ImVec2(1,1), const ImVec4& tint_col=ImVec4(1,1,1,1), ImPlotImageFlags flags=0)
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col, ImPlotImageFlags flags = (ImPlotImageFlags)(0))
        {
            var ____arg2 = bounds_min.__Instance;
            var __arg2 = new IntPtr(&____arg2);
            var ____arg3 = bounds_max.__Instance;
            var __arg3 = new IntPtr(&____arg3);
            var __arg4 = new IntPtr(Unsafe.AsPointer(ref uv0))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg5 = new IntPtr(Unsafe.AsPointer(ref uv1))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg6 = new IntPtr(Unsafe.AsPointer(ref tint_col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotImage(label_id, user_texture_id, __arg2, __arg3, __arg4, __arg5, __arg6, flags);
            }
            else
            {
                __Internal32.PlotImage(label_id, user_texture_id, __arg2, __arg3, __arg4, __arg5, __arg6, flags);
            }
        }

        /// <summary>Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L909.</summary>
        // DEBUG: void PlotText(const char* text, double x, double y, const ImVec2& pix_offset=ImVec2(0,0), ImPlotTextFlags flags=0)
        public static void PlotText(string text, double x, double y, Vector2 pix_offset, ImPlotTextFlags flags = (ImPlotTextFlags)(0))
        {
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref pix_offset))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotText(text, x, y, __arg3, flags);
            }
            else
            {
                __Internal32.PlotText(text, x, y, __arg3, flags);
            }
        }

        /// <summary>Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L912.</summary>
        // DEBUG: void PlotDummy(const char* label_id, ImPlotDummyFlags flags=0)
        public static void PlotDummy(string label_id, ImPlotDummyFlags flags = (ImPlotDummyFlags)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotDummy(label_id, flags);
            }
            else
            {
                __Internal32.PlotDummy(label_id, flags);
            }
        }

        /// <summary>Shows a draggable point at x,y. #col defaults to ImGuiCol_Text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L923.</summary>
        // DEBUG: bool DragPoint(int id, double* x, double* y, const ImVec4& col, float size = 4, ImPlotDragToolFlags flags=0)
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size = (float)(4), ImPlotDragToolFlags flags = (ImPlotDragToolFlags)(0))
        {
            fixed (double* __x1 = &x)
            {
                var __arg1 = __x1;
                fixed (double* __y2 = &y)
                {
                    var __arg2 = __y2;
                    var __arg3 = new IntPtr(Unsafe.AsPointer(ref col))
                    /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
                    /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
                    ;
                    var ___ret = Environment.Is64BitProcess ? __Internal64.DragPoint(id, __arg1, __arg2, __arg3, size, flags) : __Internal32.DragPoint(id, __arg1, __arg2, __arg3, size, flags);
                    return ___ret;
                }
            }
        }

        /// <summary>Shows a draggable vertical guide line at an x-value. #col defaults to ImGuiCol_Text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L925.</summary>
        // DEBUG: bool DragLineX(int id, double* x, const ImVec4& col, float thickness = 1, ImPlotDragToolFlags flags=0)
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness = (float)(1), ImPlotDragToolFlags flags = (ImPlotDragToolFlags)(0))
        {
            fixed (double* __x1 = &x)
            {
                var __arg1 = __x1;
                var __arg2 = new IntPtr(Unsafe.AsPointer(ref col))
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
                ;
                var ___ret = Environment.Is64BitProcess ? __Internal64.DragLineX(id, __arg1, __arg2, thickness, flags) : __Internal32.DragLineX(id, __arg1, __arg2, thickness, flags);
                return ___ret;
            }
        }

        /// <summary>Shows a draggable horizontal guide line at a y-value. #col defaults to ImGuiCol_Text.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L927.</summary>
        // DEBUG: bool DragLineY(int id, double* y, const ImVec4& col, float thickness = 1, ImPlotDragToolFlags flags=0)
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness = (float)(1), ImPlotDragToolFlags flags = (ImPlotDragToolFlags)(0))
        {
            fixed (double* __y1 = &y)
            {
                var __arg1 = __y1;
                var __arg2 = new IntPtr(Unsafe.AsPointer(ref col))
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
                ;
                var ___ret = Environment.Is64BitProcess ? __Internal64.DragLineY(id, __arg1, __arg2, thickness, flags) : __Internal32.DragLineY(id, __arg1, __arg2, thickness, flags);
                return ___ret;
            }
        }

        /// <summary>Shows a draggable and resizeable rectangle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L929.</summary>
        // DEBUG: bool DragRect(int id, double* x1, double* y1, double* x2, double* y2, const ImVec4& col, ImPlotDragToolFlags flags=0)
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags = (ImPlotDragToolFlags)(0))
        {
            fixed (double* __x11 = &x1)
            {
                var __arg1 = __x11;
                fixed (double* __y12 = &y1)
                {
                    var __arg2 = __y12;
                    fixed (double* __x23 = &x2)
                    {
                        var __arg3 = __x23;
                        fixed (double* __y24 = &y2)
                        {
                            var __arg4 = __y24;
                            var __arg5 = new IntPtr(Unsafe.AsPointer(ref col))
                            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
                            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
                            ;
                            var ___ret = Environment.Is64BitProcess ? __Internal64.DragRect(id, __arg1, __arg2, __arg3, __arg4, __arg5, flags) : __Internal32.DragRect(id, __arg1, __arg2, __arg3, __arg4, __arg5, flags);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Shows an annotation callout at a chosen point. Clamping keeps annotations in the plot area. Annotations are always rendered on top.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L932.</summary>
        // DEBUG: void Annotation(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, bool round = false)
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, bool round = false)
        {
            var __arg2 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref pix_offset))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.Annotation(x, y, __arg2, __arg3, clamp, round);
            }
            else
            {
                __Internal32.Annotation(x, y, __arg2, __arg3, clamp, round);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L933.</summary>
        // DEBUG: void Annotation(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, const char* fmt, ...)           IM_FMTARGS(6)
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, string fmt)
        {
            var __arg2 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref pix_offset))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.Annotation_1(x, y, __arg2, __arg3, clamp, fmt);
            }
            else
            {
                __Internal32.Annotation_1(x, y, __arg2, __arg3, clamp, fmt);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L934.</summary>
        // DEBUG: void AnnotationV(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, const char* fmt, va_list args) IM_FMTLIST(6)
        public static void AnnotationV(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, string fmt, Object args)
        {
            var __arg2 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref pix_offset))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.AnnotationV(x, y, __arg2, __arg3, clamp, fmt, args);
            }
            else
            {
                __Internal32.AnnotationV(x, y, __arg2, __arg3, clamp, fmt, args);
            }
        }

        /// <summary>Shows a x-axis tag at the specified coordinate value.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L937.</summary>
        // DEBUG: void TagX(double x, const ImVec4& col, bool round = false)
        public static void TagX(double x, Vector4 col, bool round = false)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagX(x, __arg1, round);
            }
            else
            {
                __Internal32.TagX(x, __arg1, round);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L938.</summary>
        // DEBUG: void TagX(double x, const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(3)
        public static void TagX(double x, Vector4 col, string fmt)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagX_1(x, __arg1, fmt);
            }
            else
            {
                __Internal32.TagX_1(x, __arg1, fmt);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L939.</summary>
        // DEBUG: void TagXV(double x, const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(3)
        public static void TagXV(double x, Vector4 col, string fmt, Object args)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagXV(x, __arg1, fmt, args);
            }
            else
            {
                __Internal32.TagXV(x, __arg1, fmt, args);
            }
        }

        /// <summary>Shows a y-axis tag at the specified coordinate value.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L942.</summary>
        // DEBUG: void TagY(double y, const ImVec4& col, bool round = false)
        public static void TagY(double y, Vector4 col, bool round = false)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagY(y, __arg1, round);
            }
            else
            {
                __Internal32.TagY(y, __arg1, round);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L943.</summary>
        // DEBUG: void TagY(double y, const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(3)
        public static void TagY(double y, Vector4 col, string fmt)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagY_1(y, __arg1, fmt);
            }
            else
            {
                __Internal32.TagY_1(y, __arg1, fmt);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L944.</summary>
        // DEBUG: void TagYV(double y, const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(3)
        public static void TagYV(double y, Vector4 col, string fmt, Object args)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.TagYV(y, __arg1, fmt, args);
            }
            else
            {
                __Internal32.TagYV(y, __arg1, fmt, args);
            }
        }

        /// <summary>Select which axis/axes will be used for subsequent plot elements.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L951.</summary>
        // DEBUG: void SetAxis(ImAxis axis)
        public static void SetAxis(ImPlotAxis axis)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetAxis(axis);
            }
            else
            {
                __Internal32.SetAxis(axis);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L952.</summary>
        // DEBUG: void SetAxes(ImAxis x_axis, ImAxis y_axis)
        public static void SetAxes(ImPlotAxis x_axis, ImPlotAxis y_axis)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetAxes(x_axis, y_axis);
            }
            else
            {
                __Internal32.SetAxes(x_axis, y_axis);
            }
        }

        /// <summary>Convert pixels to a position in the current plot's coordinate system. Passing IMPLOT_AUTO uses the current axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L955.</summary>
        // DEBUG: ImPlotPoint PixelsToPlot(const ImVec2& pix, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref pix))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var ___ret = new ImPlotPoint.__Internal();
            if (Environment.Is64BitProcess)
            {
                __Internal64.PixelsToPlot(new IntPtr(&___ret), __arg0, x_axis, y_axis);
            }
            else
            {
                __Internal32.PixelsToPlot(new IntPtr(&___ret), __arg0, x_axis, y_axis);
            }

            return ImPlotPoint.__CreateInstance(___ret);
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L956.</summary>
        // DEBUG: ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static ImPlotPoint PixelsToPlot(float x, float y, ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ___ret = new ImPlotPoint.__Internal();
            if (Environment.Is64BitProcess)
            {
                __Internal64.PixelsToPlot(new IntPtr(&___ret), x, y, x_axis, y_axis);
            }
            else
            {
                __Internal32.PixelsToPlot(new IntPtr(&___ret), x, y, x_axis, y_axis);
            }

            return ImPlotPoint.__CreateInstance(___ret);
        }

        /// <summary>Convert a position in the current plot's coordinate system to pixels. Passing IMPLOT_AUTO uses the current axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L959.</summary>
        // DEBUG: ImVec2 PlotToPixels(const ImPlotPoint& plt, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ____arg0 = plt.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            var ___ret = new Vector2();
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotToPixels(new IntPtr(&___ret), __arg0, x_axis, y_axis);
            }
            else
            {
                __Internal32.PlotToPixels(new IntPtr(&___ret), __arg0, x_axis, y_axis);
            }

            return ___ret
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L960.</summary>
        // DEBUG: ImVec2 PlotToPixels(double x, double y, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static Vector2 PlotToPixels(double x, double y, ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ___ret = new Vector2();
            if (Environment.Is64BitProcess)
            {
                __Internal64.PlotToPixels(new IntPtr(&___ret), x, y, x_axis, y_axis);
            }
            else
            {
                __Internal32.PlotToPixels(new IntPtr(&___ret), x, y, x_axis, y_axis);
            }

            return ___ret
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Get the current Plot position (top-left) in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L963.</summary>
        // DEBUG: ImVec2 GetPlotPos()
        public static Vector2 GetPlotPos()
        {
            var ___ret = new Vector2();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetPlotPos(new IntPtr(&___ret));
            }
            else
            {
                __Internal32.GetPlotPos(new IntPtr(&___ret));
            }

            return ___ret
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Get the curent Plot size in pixels.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L965.</summary>
        // DEBUG: ImVec2 GetPlotSize()
        public static Vector2 GetPlotSize()
        {
            var ___ret = new Vector2();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetPlotSize(new IntPtr(&___ret));
            }
            else
            {
                __Internal32.GetPlotSize(new IntPtr(&___ret));
            }

            return ___ret
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Returns the mouse position in x,y coordinates of the current plot. Passing IMPLOT_AUTO uses the current axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L968.</summary>
        // DEBUG: ImPlotPoint GetPlotMousePos(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static ImPlotPoint GetPlotMousePos(ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ___ret = new ImPlotPoint.__Internal();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetPlotMousePos(new IntPtr(&___ret), x_axis, y_axis);
            }
            else
            {
                __Internal32.GetPlotMousePos(new IntPtr(&___ret), x_axis, y_axis);
            }

            return ImPlotPoint.__CreateInstance(___ret);
        }

        /// <summary>Returns the current plot axis range.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L970.</summary>
        // DEBUG: ImPlotRect GetPlotLimits(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static ImPlotRect GetPlotLimits(ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ___ret = new ImPlotRect.__Internal();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetPlotLimits(new IntPtr(&___ret), x_axis, y_axis);
            }
            else
            {
                __Internal32.GetPlotLimits(new IntPtr(&___ret), x_axis, y_axis);
            }

            return ImPlotRect.__CreateInstance(___ret);
        }

        /// <summary>Returns true if the plot area in the current plot is hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L973.</summary>
        // DEBUG: bool IsPlotHovered()
        public static bool IsPlotHovered()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.IsPlotHovered() : __Internal32.IsPlotHovered();
            return ___ret;
        }

        /// <summary>Returns true if the axis label area in the current plot is hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L975.</summary>
        // DEBUG: bool IsAxisHovered(ImAxis axis)
        public static bool IsAxisHovered(ImPlotAxis axis)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.IsAxisHovered(axis) : __Internal32.IsAxisHovered(axis);
            return ___ret;
        }

        /// <summary>Returns true if the bounding frame of a subplot is hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L977.</summary>
        // DEBUG: bool IsSubplotsHovered()
        public static bool IsSubplotsHovered()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.IsSubplotsHovered() : __Internal32.IsSubplotsHovered();
            return ___ret;
        }

        /// <summary>Returns true if the current plot is being box selected.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L980.</summary>
        // DEBUG: bool IsPlotSelected()
        public static bool IsPlotSelected()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.IsPlotSelected() : __Internal32.IsPlotSelected();
            return ___ret;
        }

        /// <summary>Returns the current plot box selection bounds. Passing IMPLOT_AUTO uses the current axes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L982.</summary>
        // DEBUG: ImPlotRect GetPlotSelection(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO)
        public static ImPlotRect GetPlotSelection(ImPlotAxis x_axis = (ImPlotAxis)(-1), ImPlotAxis y_axis = (ImPlotAxis)(-1))
        {
            var ___ret = new ImPlotRect.__Internal();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetPlotSelection(new IntPtr(&___ret), x_axis, y_axis);
            }
            else
            {
                __Internal32.GetPlotSelection(new IntPtr(&___ret), x_axis, y_axis);
            }

            return ImPlotRect.__CreateInstance(___ret);
        }

        /// <summary>Cancels a the current plot box selection.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L984.</summary>
        // DEBUG: void CancelPlotSelection()
        public static void CancelPlotSelection()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.CancelPlotSelection();
            }
            else
            {
                __Internal32.CancelPlotSelection();
            }
        }

        /// <summary>Hides or shows the next plot item (i.e. as if it were toggled from the legend).<br/>Use ImPlotCond_Always if you need to forcefully set this every frame.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L988.</summary>
        // DEBUG: void HideNextItem(bool hidden = true, ImPlotCond cond = ImPlotCond_Once)
        public static void HideNextItem(bool hidden = true, ImPlotCond cond = ImPlotCond.Once)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.HideNextItem(hidden, cond);
            }
            else
            {
                __Internal32.HideNextItem(hidden, cond);
            }
        }

        /// <summary>Align axis padding over multiple plots in a single row or column. #group_id must.<br/>Be unique. If this function returns true, EndAlignedPlots() must be called.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L997.</summary>
        // DEBUG: bool BeginAlignedPlots(const char* group_id, bool vertical = true)
        public static bool BeginAlignedPlots(string group_id, bool vertical = true)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginAlignedPlots(group_id, vertical) : __Internal32.BeginAlignedPlots(group_id, vertical);
            return ___ret;
        }

        /// <summary>Only call EndAlignedPlots() if BeginAlignedPlots() returns true!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L999.</summary>
        // DEBUG: void EndAlignedPlots()
        public static void EndAlignedPlots()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndAlignedPlots();
            }
            else
            {
                __Internal32.EndAlignedPlots();
            }
        }

        /// <summary>Begin a popup for a legend entry.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1006.</summary>
        // DEBUG: bool BeginLegendPopup(const char* label_id, ImGuiMouseButton mouse_button=1)
        public static bool BeginLegendPopup(string label_id, ImGuiMouseButton mouse_button = (ImGuiMouseButton)(1))
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginLegendPopup(label_id, mouse_button) : __Internal32.BeginLegendPopup(label_id, mouse_button);
            return ___ret;
        }

        /// <summary>End a popup for a legend entry.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1008.</summary>
        // DEBUG: void EndLegendPopup()
        public static void EndLegendPopup()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndLegendPopup();
            }
            else
            {
                __Internal32.EndLegendPopup();
            }
        }

        /// <summary>Returns true if a plot item legend entry is hovered.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1010.</summary>
        // DEBUG: bool IsLegendEntryHovered(const char* label_id)
        public static bool IsLegendEntryHovered(string label_id)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.IsLegendEntryHovered(label_id) : __Internal32.IsLegendEntryHovered(label_id);
            return ___ret;
        }

        /// <summary>Turns the current plot's plotting area into a drag and drop target. Don't forget to call EndDragDropTarget!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1017.</summary>
        // DEBUG: bool BeginDragDropTargetPlot()
        public static bool BeginDragDropTargetPlot()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropTargetPlot() : __Internal32.BeginDragDropTargetPlot();
            return ___ret;
        }

        /// <summary>Turns the current plot's X-axis into a drag and drop target. Don't forget to call EndDragDropTarget!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1019.</summary>
        // DEBUG: bool BeginDragDropTargetAxis(ImAxis axis)
        public static bool BeginDragDropTargetAxis(ImPlotAxis axis)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropTargetAxis(axis) : __Internal32.BeginDragDropTargetAxis(axis);
            return ___ret;
        }

        /// <summary>Turns the current plot's legend into a drag and drop target. Don't forget to call EndDragDropTarget!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1021.</summary>
        // DEBUG: bool BeginDragDropTargetLegend()
        public static bool BeginDragDropTargetLegend()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropTargetLegend() : __Internal32.BeginDragDropTargetLegend();
            return ___ret;
        }

        /// <summary>Ends a drag and drop target (currently just an alias for ImGui::EndDragDropTarget).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1023.</summary>
        // DEBUG: void EndDragDropTarget()
        public static void EndDragDropTarget()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndDragDropTarget();
            }
            else
            {
                __Internal32.EndDragDropTarget();
            }
        }

        /// <summary>Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1029.</summary>
        // DEBUG: bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags=0)
        public static bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags = (ImGuiDragDropFlags)(0))
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropSourcePlot(flags) : __Internal32.BeginDragDropSourcePlot(flags);
            return ___ret;
        }

        /// <summary>Turns the current plot's X-axis into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1031.</summary>
        // DEBUG: bool BeginDragDropSourceAxis(ImAxis axis, ImGuiDragDropFlags flags=0)
        public static bool BeginDragDropSourceAxis(ImPlotAxis axis, ImGuiDragDropFlags flags = (ImGuiDragDropFlags)(0))
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropSourceAxis(axis, flags) : __Internal32.BeginDragDropSourceAxis(axis, flags);
            return ___ret;
        }

        /// <summary>Turns an item in the current plot's legend into drag and drop source. Don't forget to call EndDragDropSource!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1033.</summary>
        // DEBUG: bool BeginDragDropSourceItem(const char* label_id, ImGuiDragDropFlags flags=0)
        public static bool BeginDragDropSourceItem(string label_id, ImGuiDragDropFlags flags = (ImGuiDragDropFlags)(0))
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.BeginDragDropSourceItem(label_id, flags) : __Internal32.BeginDragDropSourceItem(label_id, flags);
            return ___ret;
        }

        /// <summary>Ends a drag and drop source (currently just an alias for ImGui::EndDragDropSource).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1035.</summary>
        // DEBUG: void EndDragDropSource()
        public static void EndDragDropSource()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.EndDragDropSource();
            }
            else
            {
                __Internal32.EndDragDropSource();
            }
        }

        /// <summary>Provides access to plot style structure for permanant modifications to colors, sizes, etc.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1071.</summary>
        // DEBUG: ImPlotStyle& GetStyle()
        public static ImPlotStyle GetStyle()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetStyle() : __Internal32.GetStyle();
            var __result0 = ImPlotStyle.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Style plot colors for current ImGui style (default).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1074.</summary>
        // DEBUG: void StyleColorsAuto(ImPlotStyle* dst = NULL)
        public static void StyleColorsAuto(ImPlotStyle dst = default)
        {
            var __arg0 = dst is null ? IntPtr.Zero : dst.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.StyleColorsAuto(__arg0);
            }
            else
            {
                __Internal32.StyleColorsAuto(__arg0);
            }
        }

        /// <summary>Style plot colors for ImGui "Classic".<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1076.</summary>
        // DEBUG: void StyleColorsClassic(ImPlotStyle* dst = NULL)
        public static void StyleColorsClassic(ImPlotStyle dst = default)
        {
            var __arg0 = dst is null ? IntPtr.Zero : dst.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.StyleColorsClassic(__arg0);
            }
            else
            {
                __Internal32.StyleColorsClassic(__arg0);
            }
        }

        /// <summary>Style plot colors for ImGui "Dark".<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1078.</summary>
        // DEBUG: void StyleColorsDark(ImPlotStyle* dst = NULL)
        public static void StyleColorsDark(ImPlotStyle dst = default)
        {
            var __arg0 = dst is null ? IntPtr.Zero : dst.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.StyleColorsDark(__arg0);
            }
            else
            {
                __Internal32.StyleColorsDark(__arg0);
            }
        }

        /// <summary>Style plot colors for ImGui "Light".<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1080.</summary>
        // DEBUG: void StyleColorsLight(ImPlotStyle* dst = NULL)
        public static void StyleColorsLight(ImPlotStyle dst = default)
        {
            var __arg0 = dst is null ? IntPtr.Zero : dst.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.StyleColorsLight(__arg0);
            }
            else
            {
                __Internal32.StyleColorsLight(__arg0);
            }
        }

        /// <summary>Temporarily modify a style color. Don't forget to call PopStyleColor!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1087.</summary>
        // DEBUG: void PushStyleColor(ImPlotCol idx, ImU32 col)
        public static void PushStyleColor(ImPlotCol idx, uint col)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushStyleColor(idx, col);
            }
            else
            {
                __Internal32.PushStyleColor(idx, col);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1088.</summary>
        // DEBUG: void PushStyleColor(ImPlotCol idx, const ImVec4& col)
        public static void PushStyleColor(ImPlotCol idx, Vector4 col)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushStyleColor(idx, __arg1);
            }
            else
            {
                __Internal32.PushStyleColor(idx, __arg1);
            }
        }

        /// <summary>Undo temporary style color modification(s). Undo multiple pushes at once by increasing count.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1090.</summary>
        // DEBUG: void PopStyleColor(int count = 1)
        public static void PopStyleColor(int count = (int)(1))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PopStyleColor(count);
            }
            else
            {
                __Internal32.PopStyleColor(count);
            }
        }

        /// <summary>Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1093.</summary>
        // DEBUG: void PushStyleVar(ImPlotStyleVar idx, float val)
        public static void PushStyleVar(ImPlotStyleVar idx, float val)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushStyleVar(idx, val);
            }
            else
            {
                __Internal32.PushStyleVar(idx, val);
            }
        }

        /// <summary>Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1095.</summary>
        // DEBUG: void PushStyleVar(ImPlotStyleVar idx, int val)
        public static void PushStyleVar(ImPlotStyleVar idx, int val)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushStyleVar_1(idx, val);
            }
            else
            {
                __Internal32.PushStyleVar_1(idx, val);
            }
        }

        /// <summary>Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1097.</summary>
        // DEBUG: void PushStyleVar(ImPlotStyleVar idx, const ImVec2& val)
        public static void PushStyleVar(ImPlotStyleVar idx, Vector2 val)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref val))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushStyleVar(idx, __arg1);
            }
            else
            {
                __Internal32.PushStyleVar(idx, __arg1);
            }
        }

        /// <summary>Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1099.</summary>
        // DEBUG: void PopStyleVar(int count = 1)
        public static void PopStyleVar(int count = (int)(1))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PopStyleVar(count);
            }
            else
            {
                __Internal32.PopStyleVar(count);
            }
        }

        /// <summary>Set the line color and weight for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1107.</summary>
        // DEBUG: void SetNextLineStyle(const ImVec4& col = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO)
        public static void SetNextLineStyle(Vector4 col, float weight = (float)(-1))
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextLineStyle(__arg0, weight);
            }
            else
            {
                __Internal32.SetNextLineStyle(__arg0, weight);
            }
        }

        /// <summary>Set the fill color for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1109.</summary>
        // DEBUG: void SetNextFillStyle(const ImVec4& col = IMPLOT_AUTO_COL, float alpha_mod = IMPLOT_AUTO)
        public static void SetNextFillStyle(Vector4 col, float alpha_mod = (float)(-1))
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextFillStyle(__arg0, alpha_mod);
            }
            else
            {
                __Internal32.SetNextFillStyle(__arg0, alpha_mod);
            }
        }

        /// <summary>Set the marker style for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1111.</summary>
        // DEBUG: void SetNextMarkerStyle(ImPlotMarker marker = IMPLOT_AUTO, float size = IMPLOT_AUTO, const ImVec4& fill = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO, const ImVec4& outline = IMPLOT_AUTO_COL)
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight, Vector4 outline)
        {
            var __arg2 = new IntPtr(Unsafe.AsPointer(ref fill))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var __arg4 = new IntPtr(Unsafe.AsPointer(ref outline))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextMarkerStyle(marker, size, __arg2, weight, __arg4);
            }
            else
            {
                __Internal32.SetNextMarkerStyle(marker, size, __arg2, weight, __arg4);
            }
        }

        /// <summary>Set the error bar style for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1113.</summary>
        // DEBUG: void SetNextErrorBarStyle(const ImVec4& col = IMPLOT_AUTO_COL, float size = IMPLOT_AUTO, float weight = IMPLOT_AUTO)
        public static void SetNextErrorBarStyle(Vector4 col, float size = (float)(-1), float weight = (float)(-1))
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.SetNextErrorBarStyle(__arg0, size, weight);
            }
            else
            {
                __Internal32.SetNextErrorBarStyle(__arg0, size, weight);
            }
        }

        /// <summary>Gets the last item primary color (i.e. its legend icon color).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1116.</summary>
        // DEBUG: ImVec4 GetLastItemColor()
        public static Vector4 GetLastItemColor()
        {
            var ___ret = new Vector4();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetLastItemColor(new IntPtr(&___ret));
            }
            else
            {
                __Internal32.GetLastItemColor(new IntPtr(&___ret));
            }

            return ___ret
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Returns the null terminated string name for an ImPlotCol.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1119.</summary>
        // DEBUG: const char* GetStyleColorName(ImPlotCol idx)
        public static string GetStyleColorName(ImPlotCol idx)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetStyleColorName(idx) : __Internal32.GetStyleColorName(idx);
            return CppSharp.Runtime.MarshalUtil.GetString(Encoding.UTF8, ___ret);
        }

        /// <summary>Returns the null terminated string name for an ImPlotMarker.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1121.</summary>
        // DEBUG: const char* GetMarkerName(ImPlotMarker idx)
        public static string GetMarkerName(ImPlotMarker idx)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetMarkerName(idx) : __Internal32.GetMarkerName(idx);
            return CppSharp.Runtime.MarshalUtil.GetString(Encoding.UTF8, ___ret);
        }

        /// <summary>Add a new colormap. The color data will be copied. The colormap can be used by pushing either the returned index or the.<br/>String name with PushColormap. The colormap name must be unique and the size must be greater than 1. You will receive.<br/>An assert otherwise! By default colormaps are considered to be qualitative (i.e. discrete). If you want to create a.<br/>Continuous colormap, set #qual=false. This will treat the colors you provide as keys, and ImPlot will build a linearly.<br/>Interpolated lookup table. The memory footprint of this table will be exactly ((size-1)*255+1)*4 bytes.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1142.</summary>
        // DEBUG: ImPlotColormap AddColormap(const char* name, const ImVec4* cols, int size, bool qual=true)
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size, bool qual = true)
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref cols))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var ___ret = Environment.Is64BitProcess ? __Internal64.AddColormap(name, __arg1, size, qual) : __Internal32.AddColormap(name, __arg1, size, qual);
            return ___ret;
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1143.</summary>
        // DEBUG: ImPlotColormap AddColormap(const char* name, const ImU32*  cols, int size, bool qual=true)
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size, bool qual = true)
        {
            fixed (uint* __cols1 = &cols)
            {
                var __arg1 = __cols1;
                var ___ret = Environment.Is64BitProcess ? __Internal64.AddColormap(name, __arg1, size, qual) : __Internal32.AddColormap(name, __arg1, size, qual);
                return ___ret;
            }
        }

        /// <summary>Returns the number of available colormaps (i.e. the built-in + user-added count).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1146.</summary>
        // DEBUG: int GetColormapCount()
        public static int GetColormapCount()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetColormapCount() : __Internal32.GetColormapCount();
            return ___ret;
        }

        /// <summary>Returns a null terminated string name for a colormap given an index. Returns NULL if index is invalid.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1148.</summary>
        // DEBUG: const char* GetColormapName(ImPlotColormap cmap)
        public static string GetColormapName(ImPlotColormap cmap)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetColormapName(cmap) : __Internal32.GetColormapName(cmap);
            return CppSharp.Runtime.MarshalUtil.GetString(Encoding.UTF8, ___ret);
        }

        /// <summary>Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1150.</summary>
        // DEBUG: ImPlotColormap GetColormapIndex(const char* name)
        public static ImPlotColormap GetColormapIndex(string name)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetColormapIndex(name) : __Internal32.GetColormapIndex(name);
            return ___ret;
        }

        /// <summary>Temporarily switch to one of the built-in (i.e. ImPlotColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to call PopColormap!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1153.</summary>
        // DEBUG: void PushColormap(ImPlotColormap cmap)
        public static void PushColormap(ImPlotColormap cmap)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushColormap(cmap);
            }
            else
            {
                __Internal32.PushColormap(cmap);
            }
        }

        /// <summary>Push a colormap by string name. Use built-in names such as "Default", "Deep", "Jet", etc. or a string you provided to AddColormap. Don't forget to call PopColormap!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1155.</summary>
        // DEBUG: void PushColormap(const char* name)
        public static void PushColormap(string name)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushColormap_1(name);
            }
            else
            {
                __Internal32.PushColormap_1(name);
            }
        }

        /// <summary>Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1157.</summary>
        // DEBUG: void PopColormap(int count = 1)
        public static void PopColormap(int count = (int)(1))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PopColormap(count);
            }
            else
            {
                __Internal32.PopColormap(count);
            }
        }

        /// <summary>Returns the next color from the current colormap and advances the colormap for the current plot.<br/>Can also be used with no return value to skip colors if desired. You need to call this between Begin/EndPlot!<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1161.</summary>
        // DEBUG: ImVec4 NextColormapColor()
        public static Vector4 NextColormapColor()
        {
            var ___ret = new Vector4();
            if (Environment.Is64BitProcess)
            {
                __Internal64.NextColormapColor(new IntPtr(&___ret));
            }
            else
            {
                __Internal32.NextColormapColor(new IntPtr(&___ret));
            }

            return ___ret
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Returns the size of a colormap.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1167.</summary>
        // DEBUG: int GetColormapSize(ImPlotColormap cmap = IMPLOT_AUTO)
        public static int GetColormapSize(ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetColormapSize(cmap) : __Internal32.GetColormapSize(cmap);
            return ___ret;
        }

        /// <summary>Returns a color from a colormap given an index &gt;= 0 (modulo will be performed).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1169.</summary>
        // DEBUG: ImVec4 GetColormapColor(int idx, ImPlotColormap cmap = IMPLOT_AUTO)
        public static Vector4 GetColormapColor(int idx, ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            var ___ret = new Vector4();
            if (Environment.Is64BitProcess)
            {
                __Internal64.GetColormapColor(new IntPtr(&___ret), idx, cmap);
            }
            else
            {
                __Internal32.GetColormapColor(new IntPtr(&___ret), idx, cmap);
            }

            return ___ret
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Sample a color from the current colormap given t between 0 and 1.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1171.</summary>
        // DEBUG: ImVec4 SampleColormap(float t, ImPlotColormap cmap = IMPLOT_AUTO)
        public static Vector4 SampleColormap(float t, ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            var ___ret = new Vector4();
            if (Environment.Is64BitProcess)
            {
                __Internal64.SampleColormap(new IntPtr(&___ret), t, cmap);
            }
            else
            {
                __Internal32.SampleColormap(new IntPtr(&___ret), t, cmap);
            }

            return ___ret
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Case 6 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToManaged: Function: True, ReturnVarName: True */
            ;
        }

        /// <summary>Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. "##NoLabel"). If scale_min &gt; scale_max, the scale to color mapping will be reversed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1174.</summary>
        // DEBUG: void ColormapScale(const char* label, double scale_min, double scale_max, const ImVec2& size = ImVec2(0,0), const char* format = "%g", ImPlotColormapScaleFlags flags = 0, ImPlotColormap cmap = IMPLOT_AUTO)
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format = "%g", ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)(0), ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            var __arg3 = new IntPtr(Unsafe.AsPointer(ref size))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.ColormapScale(label, scale_min, scale_max, __arg3, format, flags, cmap);
            }
            else
            {
                __Internal32.ColormapScale(label, scale_min, scale_max, __arg3, format, flags, cmap);
            }
        }

        /// <summary>Shows a horizontal slider with a colormap gradient background. Optionally returns the color sampled at t in [0 1].<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1176.</summary>
        // DEBUG: bool ColormapSlider(const char* label, float* t, ImVec4* out = NULL, const char* format = "", ImPlotColormap cmap = IMPLOT_AUTO)
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format = "", ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            fixed (float* __t1 = &t)
            {
                var __arg1 = __t1;
                @out = new Vector4();
                var __arg2 = new IntPtr(Unsafe.AsPointer(ref @out))
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 5 */
                /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
                ;
                var ___ret = Environment.Is64BitProcess ? __Internal64.ColormapSlider(label, __arg1, __arg2, format, cmap) : __Internal32.ColormapSlider(label, __arg1, __arg2, format, cmap);
                return ___ret;
            }
        }

        /// <summary>Shows a button with a colormap gradient brackground.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1178.</summary>
        // DEBUG: bool ColormapButton(const char* label, const ImVec2& size = ImVec2(0,0), ImPlotColormap cmap = IMPLOT_AUTO)
        public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap = (ImPlotColormap)(-1))
        {
            var __arg1 = new IntPtr(Unsafe.AsPointer(ref size))
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Case 3 */
            /* DEBUG: TypeMapImVec2.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            var ___ret = Environment.Is64BitProcess ? __Internal64.ColormapButton(label, __arg1, cmap) : __Internal32.ColormapButton(label, __arg1, cmap);
            return ___ret;
        }

        /// <summary>When items in a plot sample their color from a colormap, the color is cached and does not change.<br/>Unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted,.<br/>Item colors will NOT update. If you need item colors to resample the new colormap, then use this.<br/>Function to bust the cached colors. If #plot_title_id is NULL, then every item in EVERY existing plot.<br/>Will be cache busted. Otherwise only the plot specified by #plot_title_id will be busted. For the.<br/>Latter, this function must be called in the same ImGui ID scope that the plot is in. You should rarely if ever.<br/>Need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1187.</summary>
        // DEBUG: void BustColorCache(const char* plot_title_id = NULL)
        public static void BustColorCache(string plot_title_id = default)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.BustColorCache(plot_title_id);
            }
            else
            {
                __Internal32.BustColorCache(plot_title_id);
            }
        }

        /// <summary>Provides access to input mapping structure for permanant modifications to controls for pan, select, etc.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1194.</summary>
        // DEBUG: ImPlotInputMap& GetInputMap()
        public static ImPlotInputMap GetInputMap()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetInputMap() : __Internal32.GetInputMap();
            var __result0 = ___ret != IntPtr.Zero ? ImPlotInputMap.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>Default input mapping: pan = LMB drag, box select = RMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1197.</summary>
        // DEBUG: void MapInputDefault(ImPlotInputMap* dst = NULL)
        public static void MapInputDefault(ImPlotInputMap dst = default)
        {
            var ____arg0 = dst.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            if (Environment.Is64BitProcess)
            {
                __Internal64.MapInputDefault(__arg0);
            }
            else
            {
                __Internal32.MapInputDefault(__arg0);
            }
        }

        /// <summary>Reverse input mapping: pan = RMB drag, box select = LMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1199.</summary>
        // DEBUG: void MapInputReverse(ImPlotInputMap* dst = NULL)
        public static void MapInputReverse(ImPlotInputMap dst = default)
        {
            var ____arg0 = dst.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            if (Environment.Is64BitProcess)
            {
                __Internal64.MapInputReverse(__arg0);
            }
            else
            {
                __Internal32.MapInputReverse(__arg0);
            }
        }

        /// <summary>Render icons similar to those that appear in legends (nifty for data lists).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1206.</summary>
        // DEBUG: void ItemIcon(const ImVec4& col)
        public static void ItemIcon(Vector4 col)
        {
            var __arg0 = new IntPtr(Unsafe.AsPointer(ref col))
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Case 4 */
            /* DEBUG: TypeMapImVec4.CSharpMarshalToNative: Function: True, ReturnVarName: False */
            ;
            if (Environment.Is64BitProcess)
            {
                __Internal64.ItemIcon(__arg0);
            }
            else
            {
                __Internal32.ItemIcon(__arg0);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1207.</summary>
        // DEBUG: void ItemIcon(ImU32 col)
        public static void ItemIcon(uint col)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.ItemIcon(col);
            }
            else
            {
                __Internal32.ItemIcon(col);
            }
        }

        /// <summary>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1208.</summary>
        // DEBUG: void ColormapIcon(ImPlotColormap cmap)
        public static void ColormapIcon(ImPlotColormap cmap)
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.ColormapIcon(cmap);
            }
            else
            {
                __Internal32.ColormapIcon(cmap);
            }
        }

        /// <summary>Get the plot draw list for custom rendering to the current plot area. Call between Begin/EndPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1211.</summary>
        // DEBUG: ImDrawList* GetPlotDrawList()
        public static ImDrawList GetPlotDrawList()
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.GetPlotDrawList() : __Internal32.GetPlotDrawList();
            var __result0 = ___ret != IntPtr.Zero ? ImDrawList.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>Push clip rect for rendering to current plot area. The rect can be expanded or contracted by #expand pixels. Call between Begin/EndPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1213.</summary>
        // DEBUG: void PushPlotClipRect(float expand=0)
        public static void PushPlotClipRect(float expand = (float)(0))
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PushPlotClipRect(expand);
            }
            else
            {
                __Internal32.PushPlotClipRect(expand);
            }
        }

        /// <summary>Pop plot clip rect. Call between Begin/EndPlot.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1215.</summary>
        // DEBUG: void PopPlotClipRect()
        public static void PopPlotClipRect()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.PopPlotClipRect();
            }
            else
            {
                __Internal32.PopPlotClipRect();
            }
        }

        /// <summary>Shows ImPlot style selector dropdown menu.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1218.</summary>
        // DEBUG: bool ShowStyleSelector(const char* label)
        public static bool ShowStyleSelector(string label)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.ShowStyleSelector(label) : __Internal32.ShowStyleSelector(label);
            return ___ret;
        }

        /// <summary>Shows ImPlot colormap selector dropdown menu.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1220.</summary>
        // DEBUG: bool ShowColormapSelector(const char* label)
        public static bool ShowColormapSelector(string label)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.ShowColormapSelector(label) : __Internal32.ShowColormapSelector(label);
            return ___ret;
        }

        /// <summary>Shows ImPlot input map selector dropdown menu.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1222.</summary>
        // DEBUG: bool ShowInputMapSelector(const char* label)
        public static bool ShowInputMapSelector(string label)
        {
            var ___ret = Environment.Is64BitProcess ? __Internal64.ShowInputMapSelector(label) : __Internal32.ShowInputMapSelector(label);
            return ___ret;
        }

        /// <summary>Shows ImPlot style editor block (not a window).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1224.</summary>
        // DEBUG: void ShowStyleEditor(ImPlotStyle* ref = NULL)
        public static void ShowStyleEditor(ImPlotStyle @ref = default)
        {
            var __arg0 = @ref is null ? IntPtr.Zero : @ref.__Instance;
            if (Environment.Is64BitProcess)
            {
                __Internal64.ShowStyleEditor(__arg0);
            }
            else
            {
                __Internal32.ShowStyleEditor(__arg0);
            }
        }

        /// <summary>Add basic help/info block for end users (not a window).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1226.</summary>
        // DEBUG: void ShowUserGuide()
        public static void ShowUserGuide()
        {
            if (Environment.Is64BitProcess)
            {
                __Internal64.ShowUserGuide();
            }
            else
            {
                __Internal32.ShowUserGuide();
            }
        }

        /// <summary>Shows ImPlot metrics/debug information window.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1228.</summary>
        // DEBUG: void ShowMetricsWindow(bool* p_popen = NULL)
        public static void ShowMetricsWindow(ref bool p_popen)
        {
            fixed (bool* __p_popen0 = &p_popen)
            {
                var __arg0 = __p_popen0;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ShowMetricsWindow(__arg0);
                }
                else
                {
                    __Internal32.ShowMetricsWindow(__arg0);
                }
            }
        }

        /// <summary>Shows the ImPlot demo window (add implot_demo.cpp to your sources!).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1235.</summary>
        // DEBUG: void ShowDemoWindow(bool* p_open = NULL)
        public static void ShowDemoWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                if (Environment.Is64BitProcess)
                {
                    __Internal64.ShowDemoWindow(__arg0);
                }
                else
                {
                    __Internal32.ShowDemoWindow(__arg0);
                }
            }
        }

        /// <summary>- #title_id must be unique to the current ImGui ID scope. If you need to avoid ID.<br/>Collisions or don't want to display a title in the plot, use double hashes.<br/>(e.g. "MyPlot##HiddenIdText" or "##NoTitle").<br/>- #size is the **frame** size of the plot widget, not the plot area. The default.<br/>Size of plots (i.e. when ImVec2(0,0)) can be modified in your ImPlotStyle.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L626.</summary>
        // DEBUG: bool BeginPlot(const char* title_id, const ImVec2& size=ImVec2(-1,0), ImPlotFlags flags=0)
        public static bool BeginPlot(string title_id)
        {
            return BeginPlot(title_id, new Vector2(-1, 0), 0);
        }

        /// <summary>- The #title_id parameter of _BeginPlot_ (see above) does NOT have to be.<br/>Unique when called inside of a subplot context. Subplot IDs are hashed.<br/>For your convenience so you don't have call PushID or generate unique title.<br/>Strings. Simply pass an empty string to BeginPlot unless you want to title.<br/>Each subplot.<br/>- The #size parameter of _BeginPlot_ (see above) is ignored when inside of a.<br/>Subplot context. The actual size of the subplot will be based on the.<br/>#size value you pass to _BeginSubplots_ and #row/#col_ratios if provided.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L682.</summary>
        // DEBUG: bool BeginSubplots(const char* title_id,
        // DEBUG:                              int rows,
        // DEBUG:                              int cols,
        // DEBUG:                              const ImVec2& size,
        // DEBUG:                              ImPlotSubplotFlags flags = 0,
        // DEBUG:                              float* row_ratios        = NULL,
        // DEBUG:                              float* col_ratios        = NULL)
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags = (ImPlotSubplotFlags)(0))
        {
            float param0 = 0;
            float param1 = 0;
            return BeginSubplots(title_id, rows, cols, size, flags, ref param0, ref param1);
        }

        /// <summary>- The #title_id parameter of _BeginPlot_ (see above) does NOT have to be.<br/>Unique when called inside of a subplot context. Subplot IDs are hashed.<br/>For your convenience so you don't have call PushID or generate unique title.<br/>Strings. Simply pass an empty string to BeginPlot unless you want to title.<br/>Each subplot.<br/>- The #size parameter of _BeginPlot_ (see above) is ignored when inside of a.<br/>Subplot context. The actual size of the subplot will be based on the.<br/>#size value you pass to _BeginSubplots_ and #row/#col_ratios if provided.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L682.</summary>
        // DEBUG: bool BeginSubplots(const char* title_id,
        // DEBUG:                              int rows,
        // DEBUG:                              int cols,
        // DEBUG:                              const ImVec2& size,
        // DEBUG:                              ImPlotSubplotFlags flags = 0,
        // DEBUG:                              float* row_ratios        = NULL,
        // DEBUG:                              float* col_ratios        = NULL)
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios)
        {
            float param0 = 0;
            return BeginSubplots(title_id, rows, cols, size, flags, ref row_ratios, ref param0);
        }

        /// <summary>Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L906.</summary>
        // DEBUG: void PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, const ImVec2& uv0=ImVec2(0,0), const ImVec2& uv1=ImVec2(1,1), const ImVec4& tint_col=ImVec4(1,1,1,1), ImPlotImageFlags flags=0)
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            PlotImage(label_id, user_texture_id, bounds_min, bounds_max, new Vector2(0, 0), new Vector2(1, 1), new Vector4(1, 1, 1, 1), 0);
        }

        /// <summary>Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L906.</summary>
        // DEBUG: void PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, const ImVec2& uv0=ImVec2(0,0), const ImVec2& uv1=ImVec2(1,1), const ImVec4& tint_col=ImVec4(1,1,1,1), ImPlotImageFlags flags=0)
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            PlotImage(label_id, user_texture_id, bounds_min, bounds_max, uv0, new Vector2(1, 1), new Vector4(1, 1, 1, 1), 0);
        }

        /// <summary>Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L906.</summary>
        // DEBUG: void PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, const ImVec2& uv0=ImVec2(0,0), const ImVec2& uv1=ImVec2(1,1), const ImVec4& tint_col=ImVec4(1,1,1,1), ImPlotImageFlags flags=0)
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            PlotImage(label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, new Vector4(1, 1, 1, 1), 0);
        }

        /// <summary>Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L909.</summary>
        // DEBUG: void PlotText(const char* text, double x, double y, const ImVec2& pix_offset=ImVec2(0,0), ImPlotTextFlags flags=0)
        public static void PlotText(string text, double x, double y)
        {
            PlotText(text, x, y, new Vector2(0, 0), 0);
        }

        /// <summary>Set the line color and weight for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1107.</summary>
        // DEBUG: void SetNextLineStyle(const ImVec4& col = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO)
        public static void SetNextLineStyle()
        {
            SetNextLineStyle(new Vector4(0, 0, 0, -1), -1);
        }

        /// <summary>Set the fill color for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1109.</summary>
        // DEBUG: void SetNextFillStyle(const ImVec4& col = IMPLOT_AUTO_COL, float alpha_mod = IMPLOT_AUTO)
        public static void SetNextFillStyle()
        {
            SetNextFillStyle(new Vector4(0, 0, 0, -1), -1);
        }

        /// <summary>Set the marker style for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1111.</summary>
        // DEBUG: void SetNextMarkerStyle(ImPlotMarker marker = IMPLOT_AUTO, float size = IMPLOT_AUTO, const ImVec4& fill = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO, const ImVec4& outline = IMPLOT_AUTO_COL)
        public static void SetNextMarkerStyle(ImPlotMarker marker = (ImPlotMarker)(-1), float size = (float)(-1))
        {
            SetNextMarkerStyle(marker, size, new Vector4(0, 0, 0, -1), -1, new Vector4(0, 0, 0, -1));
        }

        /// <summary>Set the marker style for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1111.</summary>
        // DEBUG: void SetNextMarkerStyle(ImPlotMarker marker = IMPLOT_AUTO, float size = IMPLOT_AUTO, const ImVec4& fill = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO, const ImVec4& outline = IMPLOT_AUTO_COL)
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight = (float)(-1))
        {
            SetNextMarkerStyle(marker, size, fill, weight, new Vector4(0, 0, 0, -1));
        }

        /// <summary>Set the error bar style for the next item only.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1113.</summary>
        // DEBUG: void SetNextErrorBarStyle(const ImVec4& col = IMPLOT_AUTO_COL, float size = IMPLOT_AUTO, float weight = IMPLOT_AUTO)
        public static void SetNextErrorBarStyle()
        {
            SetNextErrorBarStyle(new Vector4(0, 0, 0, -1), -1, -1);
        }

        /// <summary>Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. "##NoLabel"). If scale_min &gt; scale_max, the scale to color mapping will be reversed.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1174.</summary>
        // DEBUG: void ColormapScale(const char* label, double scale_min, double scale_max, const ImVec2& size = ImVec2(0,0), const char* format = "%g", ImPlotColormapScaleFlags flags = 0, ImPlotColormap cmap = IMPLOT_AUTO)
        public static void ColormapScale(string label, double scale_min, double scale_max)
        {
            ColormapScale(label, scale_min, scale_max, new Vector2(0, 0), "%g", 0, (ImPlotColormap)(-1));
        }

        /// <summary>Shows a button with a colormap gradient brackground.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1178.</summary>
        // DEBUG: bool ColormapButton(const char* label, const ImVec2& size = ImVec2(0,0), ImPlotColormap cmap = IMPLOT_AUTO)
        public static bool ColormapButton(string label)
        {
            return ColormapButton(label, new Vector2(0, 0), (ImPlotColormap)(-1));
        }

        /// <summary>Shows ImPlot metrics/debug information window.<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1228.</summary>
        // DEBUG: void ShowMetricsWindow(bool* p_popen = NULL)
        public static void ShowMetricsWindow()
        {
            bool param0 = false;
            ShowMetricsWindow(ref param0);
        }

        /// <summary>Shows the ImPlot demo window (add implot_demo.cpp to your sources!).<br/>https://github.com/epezent/implot/blob/15e494b76a78b44ae2c1b76608ff9bc39a661409/implot.h#L1235.</summary>
        // DEBUG: void ShowDemoWindow(bool* p_open = NULL)
        public static void ShowDemoWindow()
        {
            bool param0 = false;
            ShowDemoWindow(ref param0);
        }
    }
}